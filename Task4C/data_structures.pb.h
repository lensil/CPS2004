// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: data_structures.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_data_5fstructures_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_data_5fstructures_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_data_5fstructures_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_data_5fstructures_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_data_5fstructures_2eproto;
namespace com {
namespace cps2004 {
class Action;
struct ActionDefaultTypeInternal;
extern ActionDefaultTypeInternal _Action_default_instance_;
class Book;
struct BookDefaultTypeInternal;
extern BookDefaultTypeInternal _Book_default_instance_;
class Camera;
struct CameraDefaultTypeInternal;
extern CameraDefaultTypeInternal _Camera_default_instance_;
class Chair;
struct ChairDefaultTypeInternal;
extern ChairDefaultTypeInternal _Chair_default_instance_;
class Clothes;
struct ClothesDefaultTypeInternal;
extern ClothesDefaultTypeInternal _Clothes_default_instance_;
class Customer;
struct CustomerDefaultTypeInternal;
extern CustomerDefaultTypeInternal _Customer_default_instance_;
class Electronics;
struct ElectronicsDefaultTypeInternal;
extern ElectronicsDefaultTypeInternal _Electronics_default_instance_;
class FictionBook;
struct FictionBookDefaultTypeInternal;
extern FictionBookDefaultTypeInternal _FictionBook_default_instance_;
class Food;
struct FoodDefaultTypeInternal;
extern FoodDefaultTypeInternal _Food_default_instance_;
class Fruit;
struct FruitDefaultTypeInternal;
extern FruitDefaultTypeInternal _Fruit_default_instance_;
class Furniture;
struct FurnitureDefaultTypeInternal;
extern FurnitureDefaultTypeInternal _Furniture_default_instance_;
class Laptop;
struct LaptopDefaultTypeInternal;
extern LaptopDefaultTypeInternal _Laptop_default_instance_;
class Package;
struct PackageDefaultTypeInternal;
extern PackageDefaultTypeInternal _Package_default_instance_;
class Pants;
struct PantsDefaultTypeInternal;
extern PantsDefaultTypeInternal _Pants_default_instance_;
class Plane;
struct PlaneDefaultTypeInternal;
extern PlaneDefaultTypeInternal _Plane_default_instance_;
class PremadeLunch;
struct PremadeLunchDefaultTypeInternal;
extern PremadeLunchDefaultTypeInternal _PremadeLunch_default_instance_;
class Product;
struct ProductDefaultTypeInternal;
extern ProductDefaultTypeInternal _Product_default_instance_;
class RPG;
struct RPGDefaultTypeInternal;
extern RPGDefaultTypeInternal _RPG_default_instance_;
class Ship;
struct ShipDefaultTypeInternal;
extern ShipDefaultTypeInternal _Ship_default_instance_;
class Shipment;
struct ShipmentDefaultTypeInternal;
extern ShipmentDefaultTypeInternal _Shipment_default_instance_;
class ShipmentItem;
struct ShipmentItemDefaultTypeInternal;
extern ShipmentItemDefaultTypeInternal _ShipmentItem_default_instance_;
class State;
struct StateDefaultTypeInternal;
extern StateDefaultTypeInternal _State_default_instance_;
class Stock;
struct StockDefaultTypeInternal;
extern StockDefaultTypeInternal _Stock_default_instance_;
class StockItem;
struct StockItemDefaultTypeInternal;
extern StockItemDefaultTypeInternal _StockItem_default_instance_;
class Supplier;
struct SupplierDefaultTypeInternal;
extern SupplierDefaultTypeInternal _Supplier_default_instance_;
class TShirt;
struct TShirtDefaultTypeInternal;
extern TShirtDefaultTypeInternal _TShirt_default_instance_;
class Table;
struct TableDefaultTypeInternal;
extern TableDefaultTypeInternal _Table_default_instance_;
class Textbook;
struct TextbookDefaultTypeInternal;
extern TextbookDefaultTypeInternal _Textbook_default_instance_;
class Transport;
struct TransportDefaultTypeInternal;
extern TransportDefaultTypeInternal _Transport_default_instance_;
class Truck;
struct TruckDefaultTypeInternal;
extern TruckDefaultTypeInternal _Truck_default_instance_;
class VideoGame;
struct VideoGameDefaultTypeInternal;
extern VideoGameDefaultTypeInternal _VideoGame_default_instance_;
}  // namespace cps2004
}  // namespace com
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace com {
namespace cps2004 {

// ===================================================================


// -------------------------------------------------------------------

class Supplier final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.cps2004.Supplier) */ {
 public:
  inline Supplier() : Supplier(nullptr) {}
  ~Supplier() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Supplier(::google::protobuf::internal::ConstantInitialized);

  inline Supplier(const Supplier& from)
      : Supplier(nullptr, from) {}
  Supplier(Supplier&& from) noexcept
    : Supplier() {
    *this = ::std::move(from);
  }

  inline Supplier& operator=(const Supplier& from) {
    CopyFrom(from);
    return *this;
  }
  inline Supplier& operator=(Supplier&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Supplier& default_instance() {
    return *internal_default_instance();
  }
  static inline const Supplier* internal_default_instance() {
    return reinterpret_cast<const Supplier*>(
               &_Supplier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Supplier& a, Supplier& b) {
    a.Swap(&b);
  }
  inline void Swap(Supplier* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Supplier* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Supplier* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Supplier>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Supplier& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Supplier& from) {
    Supplier::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Supplier* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.cps2004.Supplier";
  }
  protected:
  explicit Supplier(::google::protobuf::Arena* arena);
  Supplier(::google::protobuf::Arena* arena, const Supplier& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kSupplierIDFieldNumber = 2,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // int32 supplierID = 2;
  void clear_supplierid() ;
  ::int32_t supplierid() const;
  void set_supplierid(::int32_t value);

  private:
  ::int32_t _internal_supplierid() const;
  void _internal_set_supplierid(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:com.cps2004.Supplier)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      33, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::int32_t supplierid_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_5fstructures_2eproto;
};// -------------------------------------------------------------------

class Plane final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.cps2004.Plane) */ {
 public:
  inline Plane() : Plane(nullptr) {}
  ~Plane() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Plane(::google::protobuf::internal::ConstantInitialized);

  inline Plane(const Plane& from)
      : Plane(nullptr, from) {}
  Plane(Plane&& from) noexcept
    : Plane() {
    *this = ::std::move(from);
  }

  inline Plane& operator=(const Plane& from) {
    CopyFrom(from);
    return *this;
  }
  inline Plane& operator=(Plane&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Plane& default_instance() {
    return *internal_default_instance();
  }
  static inline const Plane* internal_default_instance() {
    return reinterpret_cast<const Plane*>(
               &_Plane_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Plane& a, Plane& b) {
    a.Swap(&b);
  }
  inline void Swap(Plane* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Plane* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Plane* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Plane>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Plane& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Plane& from) {
    Plane::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Plane* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.cps2004.Plane";
  }
  protected:
  explicit Plane(::google::protobuf::Arena* arena);
  Plane(::google::protobuf::Arena* arena, const Plane& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAirSpacesFieldNumber = 2,
    kTransportFieldNumber = 1,
  };
  // repeated string airSpaces = 2;
  int airspaces_size() const;
  private:
  int _internal_airspaces_size() const;

  public:
  void clear_airspaces() ;
  const std::string& airspaces(int index) const;
  std::string* mutable_airspaces(int index);
  void set_airspaces(int index, const std::string& value);
  void set_airspaces(int index, std::string&& value);
  void set_airspaces(int index, const char* value);
  void set_airspaces(int index, const char* value, std::size_t size);
  void set_airspaces(int index, absl::string_view value);
  std::string* add_airspaces();
  void add_airspaces(const std::string& value);
  void add_airspaces(std::string&& value);
  void add_airspaces(const char* value);
  void add_airspaces(const char* value, std::size_t size);
  void add_airspaces(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& airspaces() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_airspaces();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_airspaces() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_airspaces();

  public:
  // .com.cps2004.Transport transport = 1;
  bool has_transport() const;
  void clear_transport() ;
  const ::com::cps2004::Transport& transport() const;
  PROTOBUF_NODISCARD ::com::cps2004::Transport* release_transport();
  ::com::cps2004::Transport* mutable_transport();
  void set_allocated_transport(::com::cps2004::Transport* value);
  void unsafe_arena_set_allocated_transport(::com::cps2004::Transport* value);
  ::com::cps2004::Transport* unsafe_arena_release_transport();

  private:
  const ::com::cps2004::Transport& _internal_transport() const;
  ::com::cps2004::Transport* _internal_mutable_transport();

  public:
  // @@protoc_insertion_point(class_scope:com.cps2004.Plane)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      35, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> airspaces_;
    ::com::cps2004::Transport* transport_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_5fstructures_2eproto;
};// -------------------------------------------------------------------

class Ship final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.cps2004.Ship) */ {
 public:
  inline Ship() : Ship(nullptr) {}
  ~Ship() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Ship(::google::protobuf::internal::ConstantInitialized);

  inline Ship(const Ship& from)
      : Ship(nullptr, from) {}
  Ship(Ship&& from) noexcept
    : Ship() {
    *this = ::std::move(from);
  }

  inline Ship& operator=(const Ship& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ship& operator=(Ship&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Ship& default_instance() {
    return *internal_default_instance();
  }
  static inline const Ship* internal_default_instance() {
    return reinterpret_cast<const Ship*>(
               &_Ship_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Ship& a, Ship& b) {
    a.Swap(&b);
  }
  inline void Swap(Ship* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ship* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Ship* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Ship>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Ship& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Ship& from) {
    Ship::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Ship* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.cps2004.Ship";
  }
  protected:
  explicit Ship(::google::protobuf::Arena* arena);
  Ship(::google::protobuf::Arena* arena, const Ship& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHarboursFieldNumber = 2,
    kTransportFieldNumber = 1,
  };
  // repeated string harbours = 2;
  int harbours_size() const;
  private:
  int _internal_harbours_size() const;

  public:
  void clear_harbours() ;
  const std::string& harbours(int index) const;
  std::string* mutable_harbours(int index);
  void set_harbours(int index, const std::string& value);
  void set_harbours(int index, std::string&& value);
  void set_harbours(int index, const char* value);
  void set_harbours(int index, const char* value, std::size_t size);
  void set_harbours(int index, absl::string_view value);
  std::string* add_harbours();
  void add_harbours(const std::string& value);
  void add_harbours(std::string&& value);
  void add_harbours(const char* value);
  void add_harbours(const char* value, std::size_t size);
  void add_harbours(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& harbours() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_harbours();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_harbours() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_harbours();

  public:
  // .com.cps2004.Transport transport = 1;
  bool has_transport() const;
  void clear_transport() ;
  const ::com::cps2004::Transport& transport() const;
  PROTOBUF_NODISCARD ::com::cps2004::Transport* release_transport();
  ::com::cps2004::Transport* mutable_transport();
  void set_allocated_transport(::com::cps2004::Transport* value);
  void unsafe_arena_set_allocated_transport(::com::cps2004::Transport* value);
  ::com::cps2004::Transport* unsafe_arena_release_transport();

  private:
  const ::com::cps2004::Transport& _internal_transport() const;
  ::com::cps2004::Transport* _internal_mutable_transport();

  public:
  // @@protoc_insertion_point(class_scope:com.cps2004.Ship)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      33, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> harbours_;
    ::com::cps2004::Transport* transport_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_5fstructures_2eproto;
};// -------------------------------------------------------------------

class Transport final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.cps2004.Transport) */ {
 public:
  inline Transport() : Transport(nullptr) {}
  ~Transport() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Transport(::google::protobuf::internal::ConstantInitialized);

  inline Transport(const Transport& from)
      : Transport(nullptr, from) {}
  Transport(Transport&& from) noexcept
    : Transport() {
    *this = ::std::move(from);
  }

  inline Transport& operator=(const Transport& from) {
    CopyFrom(from);
    return *this;
  }
  inline Transport& operator=(Transport&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Transport& default_instance() {
    return *internal_default_instance();
  }
  enum TransportTypeCase {
    kShip = 1,
    kPlane = 2,
    kTruck = 3,
    TRANSPORT_TYPE_NOT_SET = 0,
  };

  static inline const Transport* internal_default_instance() {
    return reinterpret_cast<const Transport*>(
               &_Transport_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Transport& a, Transport& b) {
    a.Swap(&b);
  }
  inline void Swap(Transport* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Transport* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Transport* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Transport>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Transport& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Transport& from) {
    Transport::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Transport* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.cps2004.Transport";
  }
  protected:
  explicit Transport(::google::protobuf::Arena* arena);
  Transport(::google::protobuf::Arena* arena, const Transport& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransportSpeedFieldNumber = 4,
    kCostPerKmFieldNumber = 5,
    kTransportIDFieldNumber = 6,
    kShipFieldNumber = 1,
    kPlaneFieldNumber = 2,
    kTruckFieldNumber = 3,
  };
  // int32 transportSpeed = 4;
  void clear_transportspeed() ;
  ::int32_t transportspeed() const;
  void set_transportspeed(::int32_t value);

  private:
  ::int32_t _internal_transportspeed() const;
  void _internal_set_transportspeed(::int32_t value);

  public:
  // int32 costPerKm = 5;
  void clear_costperkm() ;
  ::int32_t costperkm() const;
  void set_costperkm(::int32_t value);

  private:
  ::int32_t _internal_costperkm() const;
  void _internal_set_costperkm(::int32_t value);

  public:
  // int32 transportID = 6;
  void clear_transportid() ;
  ::int32_t transportid() const;
  void set_transportid(::int32_t value);

  private:
  ::int32_t _internal_transportid() const;
  void _internal_set_transportid(::int32_t value);

  public:
  // .com.cps2004.Ship ship = 1;
  bool has_ship() const;
  private:
  bool _internal_has_ship() const;

  public:
  void clear_ship() ;
  const ::com::cps2004::Ship& ship() const;
  PROTOBUF_NODISCARD ::com::cps2004::Ship* release_ship();
  ::com::cps2004::Ship* mutable_ship();
  void set_allocated_ship(::com::cps2004::Ship* value);
  void unsafe_arena_set_allocated_ship(::com::cps2004::Ship* value);
  ::com::cps2004::Ship* unsafe_arena_release_ship();

  private:
  const ::com::cps2004::Ship& _internal_ship() const;
  ::com::cps2004::Ship* _internal_mutable_ship();

  public:
  // .com.cps2004.Plane plane = 2;
  bool has_plane() const;
  private:
  bool _internal_has_plane() const;

  public:
  void clear_plane() ;
  const ::com::cps2004::Plane& plane() const;
  PROTOBUF_NODISCARD ::com::cps2004::Plane* release_plane();
  ::com::cps2004::Plane* mutable_plane();
  void set_allocated_plane(::com::cps2004::Plane* value);
  void unsafe_arena_set_allocated_plane(::com::cps2004::Plane* value);
  ::com::cps2004::Plane* unsafe_arena_release_plane();

  private:
  const ::com::cps2004::Plane& _internal_plane() const;
  ::com::cps2004::Plane* _internal_mutable_plane();

  public:
  // .com.cps2004.Truck truck = 3;
  bool has_truck() const;
  private:
  bool _internal_has_truck() const;

  public:
  void clear_truck() ;
  const ::com::cps2004::Truck& truck() const;
  PROTOBUF_NODISCARD ::com::cps2004::Truck* release_truck();
  ::com::cps2004::Truck* mutable_truck();
  void set_allocated_truck(::com::cps2004::Truck* value);
  void unsafe_arena_set_allocated_truck(::com::cps2004::Truck* value);
  ::com::cps2004::Truck* unsafe_arena_release_truck();

  private:
  const ::com::cps2004::Truck& _internal_truck() const;
  ::com::cps2004::Truck* _internal_mutable_truck();

  public:
  void clear_transport_type();
  TransportTypeCase transport_type_case() const;
  // @@protoc_insertion_point(class_scope:com.cps2004.Transport)
 private:
  class _Internal;
  void set_has_ship();
  void set_has_plane();
  void set_has_truck();

  inline bool has_transport_type() const;
  inline void clear_has_transport_type();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 6, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::int32_t transportspeed_;
    ::int32_t costperkm_;
    ::int32_t transportid_;
    union TransportTypeUnion {
      constexpr TransportTypeUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::com::cps2004::Ship* ship_;
      ::com::cps2004::Plane* plane_;
      ::com::cps2004::Truck* truck_;
    } transport_type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_5fstructures_2eproto;
};// -------------------------------------------------------------------

class Truck final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.cps2004.Truck) */ {
 public:
  inline Truck() : Truck(nullptr) {}
  ~Truck() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Truck(::google::protobuf::internal::ConstantInitialized);

  inline Truck(const Truck& from)
      : Truck(nullptr, from) {}
  Truck(Truck&& from) noexcept
    : Truck() {
    *this = ::std::move(from);
  }

  inline Truck& operator=(const Truck& from) {
    CopyFrom(from);
    return *this;
  }
  inline Truck& operator=(Truck&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Truck& default_instance() {
    return *internal_default_instance();
  }
  static inline const Truck* internal_default_instance() {
    return reinterpret_cast<const Truck*>(
               &_Truck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Truck& a, Truck& b) {
    a.Swap(&b);
  }
  inline void Swap(Truck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Truck* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Truck* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Truck>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Truck& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Truck& from) {
    Truck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Truck* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.cps2004.Truck";
  }
  protected:
  explicit Truck(::google::protobuf::Arena* arena);
  Truck(::google::protobuf::Arena* arena, const Truck& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoadsFieldNumber = 2,
    kTransportFieldNumber = 1,
  };
  // repeated string roads = 2;
  int roads_size() const;
  private:
  int _internal_roads_size() const;

  public:
  void clear_roads() ;
  const std::string& roads(int index) const;
  std::string* mutable_roads(int index);
  void set_roads(int index, const std::string& value);
  void set_roads(int index, std::string&& value);
  void set_roads(int index, const char* value);
  void set_roads(int index, const char* value, std::size_t size);
  void set_roads(int index, absl::string_view value);
  std::string* add_roads();
  void add_roads(const std::string& value);
  void add_roads(std::string&& value);
  void add_roads(const char* value);
  void add_roads(const char* value, std::size_t size);
  void add_roads(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& roads() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_roads();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_roads() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_roads();

  public:
  // .com.cps2004.Transport transport = 1;
  bool has_transport() const;
  void clear_transport() ;
  const ::com::cps2004::Transport& transport() const;
  PROTOBUF_NODISCARD ::com::cps2004::Transport* release_transport();
  ::com::cps2004::Transport* mutable_transport();
  void set_allocated_transport(::com::cps2004::Transport* value);
  void unsafe_arena_set_allocated_transport(::com::cps2004::Transport* value);
  ::com::cps2004::Transport* unsafe_arena_release_transport();

  private:
  const ::com::cps2004::Transport& _internal_transport() const;
  ::com::cps2004::Transport* _internal_mutable_transport();

  public:
  // @@protoc_insertion_point(class_scope:com.cps2004.Truck)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      31, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> roads_;
    ::com::cps2004::Transport* transport_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_5fstructures_2eproto;
};// -------------------------------------------------------------------

class Package final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.cps2004.Package) */ {
 public:
  inline Package() : Package(nullptr) {}
  ~Package() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Package(::google::protobuf::internal::ConstantInitialized);

  inline Package(const Package& from)
      : Package(nullptr, from) {}
  Package(Package&& from) noexcept
    : Package() {
    *this = ::std::move(from);
  }

  inline Package& operator=(const Package& from) {
    CopyFrom(from);
    return *this;
  }
  inline Package& operator=(Package&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Package& default_instance() {
    return *internal_default_instance();
  }
  static inline const Package* internal_default_instance() {
    return reinterpret_cast<const Package*>(
               &_Package_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Package& a, Package& b) {
    a.Swap(&b);
  }
  inline void Swap(Package* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Package* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Package* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Package>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Package& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Package& from) {
    Package::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Package* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.cps2004.Package";
  }
  protected:
  explicit Package(::google::protobuf::Arena* arena);
  Package(::google::protobuf::Arena* arena, const Package& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 3,
    kCostFieldNumber = 2,
    kPackagingUnitsFieldNumber = 1,
    kPackageIDFieldNumber = 4,
  };
  // string type = 3;
  void clear_type() ;
  const std::string& type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_type(Arg_&& arg, Args_... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* value);

  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(
      const std::string& value);
  std::string* _internal_mutable_type();

  public:
  // double cost = 2;
  void clear_cost() ;
  double cost() const;
  void set_cost(double value);

  private:
  double _internal_cost() const;
  void _internal_set_cost(double value);

  public:
  // int32 packagingUnits = 1;
  void clear_packagingunits() ;
  ::int32_t packagingunits() const;
  void set_packagingunits(::int32_t value);

  private:
  ::int32_t _internal_packagingunits() const;
  void _internal_set_packagingunits(::int32_t value);

  public:
  // int32 packageID = 4;
  void clear_packageid() ;
  ::int32_t packageid() const;
  void set_packageid(::int32_t value);

  private:
  ::int32_t _internal_packageid() const;
  void _internal_set_packageid(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:com.cps2004.Package)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      32, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr type_;
    double cost_;
    ::int32_t packagingunits_;
    ::int32_t packageid_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_5fstructures_2eproto;
};// -------------------------------------------------------------------

class Action final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.cps2004.Action) */ {
 public:
  inline Action() : Action(nullptr) {}
  ~Action() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Action(::google::protobuf::internal::ConstantInitialized);

  inline Action(const Action& from)
      : Action(nullptr, from) {}
  Action(Action&& from) noexcept
    : Action() {
    *this = ::std::move(from);
  }

  inline Action& operator=(const Action& from) {
    CopyFrom(from);
    return *this;
  }
  inline Action& operator=(Action&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Action& default_instance() {
    return *internal_default_instance();
  }
  static inline const Action* internal_default_instance() {
    return reinterpret_cast<const Action*>(
               &_Action_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(Action& a, Action& b) {
    a.Swap(&b);
  }
  inline void Swap(Action* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Action* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Action* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Action>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Action& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Action& from) {
    Action::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Action* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.cps2004.Action";
  }
  protected:
  explicit Action(::google::protobuf::Arena* arena);
  Action(::google::protobuf::Arena* arena, const Action& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRatingFieldNumber = 3,
    kVideoGameFieldNumber = 1,
    kNoOfPlayersFieldNumber = 2,
  };
  // string rating = 3;
  void clear_rating() ;
  const std::string& rating() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_rating(Arg_&& arg, Args_... args);
  std::string* mutable_rating();
  PROTOBUF_NODISCARD std::string* release_rating();
  void set_allocated_rating(std::string* value);

  private:
  const std::string& _internal_rating() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rating(
      const std::string& value);
  std::string* _internal_mutable_rating();

  public:
  // .com.cps2004.VideoGame videoGame = 1;
  bool has_videogame() const;
  void clear_videogame() ;
  const ::com::cps2004::VideoGame& videogame() const;
  PROTOBUF_NODISCARD ::com::cps2004::VideoGame* release_videogame();
  ::com::cps2004::VideoGame* mutable_videogame();
  void set_allocated_videogame(::com::cps2004::VideoGame* value);
  void unsafe_arena_set_allocated_videogame(::com::cps2004::VideoGame* value);
  ::com::cps2004::VideoGame* unsafe_arena_release_videogame();

  private:
  const ::com::cps2004::VideoGame& _internal_videogame() const;
  ::com::cps2004::VideoGame* _internal_mutable_videogame();

  public:
  // int32 noOfPlayers = 2;
  void clear_noofplayers() ;
  ::int32_t noofplayers() const;
  void set_noofplayers(::int32_t value);

  private:
  ::int32_t _internal_noofplayers() const;
  void _internal_set_noofplayers(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:com.cps2004.Action)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      33, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr rating_;
    ::com::cps2004::VideoGame* videogame_;
    ::int32_t noofplayers_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_5fstructures_2eproto;
};// -------------------------------------------------------------------

class Book final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.cps2004.Book) */ {
 public:
  inline Book() : Book(nullptr) {}
  ~Book() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Book(::google::protobuf::internal::ConstantInitialized);

  inline Book(const Book& from)
      : Book(nullptr, from) {}
  Book(Book&& from) noexcept
    : Book() {
    *this = ::std::move(from);
  }

  inline Book& operator=(const Book& from) {
    CopyFrom(from);
    return *this;
  }
  inline Book& operator=(Book&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Book& default_instance() {
    return *internal_default_instance();
  }
  enum BookTypeCase {
    kFictionBook = 1,
    kTextbook = 2,
    BOOK_TYPE_NOT_SET = 0,
  };

  static inline const Book* internal_default_instance() {
    return reinterpret_cast<const Book*>(
               &_Book_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Book& a, Book& b) {
    a.Swap(&b);
  }
  inline void Swap(Book* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Book* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Book* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Book>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Book& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Book& from) {
    Book::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Book* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.cps2004.Book";
  }
  protected:
  explicit Book(::google::protobuf::Arena* arena);
  Book(::google::protobuf::Arena* arena, const Book& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublisherFieldNumber = 4,
    kAuthorFieldNumber = 6,
    kProductFieldNumber = 3,
    kPagesFieldNumber = 5,
    kFictionBookFieldNumber = 1,
    kTextbookFieldNumber = 2,
  };
  // string publisher = 4;
  void clear_publisher() ;
  const std::string& publisher() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_publisher(Arg_&& arg, Args_... args);
  std::string* mutable_publisher();
  PROTOBUF_NODISCARD std::string* release_publisher();
  void set_allocated_publisher(std::string* value);

  private:
  const std::string& _internal_publisher() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_publisher(
      const std::string& value);
  std::string* _internal_mutable_publisher();

  public:
  // string author = 6;
  void clear_author() ;
  const std::string& author() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_author(Arg_&& arg, Args_... args);
  std::string* mutable_author();
  PROTOBUF_NODISCARD std::string* release_author();
  void set_allocated_author(std::string* value);

  private:
  const std::string& _internal_author() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_author(
      const std::string& value);
  std::string* _internal_mutable_author();

  public:
  // .com.cps2004.Product product = 3;
  bool has_product() const;
  void clear_product() ;
  const ::com::cps2004::Product& product() const;
  PROTOBUF_NODISCARD ::com::cps2004::Product* release_product();
  ::com::cps2004::Product* mutable_product();
  void set_allocated_product(::com::cps2004::Product* value);
  void unsafe_arena_set_allocated_product(::com::cps2004::Product* value);
  ::com::cps2004::Product* unsafe_arena_release_product();

  private:
  const ::com::cps2004::Product& _internal_product() const;
  ::com::cps2004::Product* _internal_mutable_product();

  public:
  // int32 pages = 5;
  void clear_pages() ;
  ::int32_t pages() const;
  void set_pages(::int32_t value);

  private:
  ::int32_t _internal_pages() const;
  void _internal_set_pages(::int32_t value);

  public:
  // .com.cps2004.FictionBook fictionBook = 1;
  bool has_fictionbook() const;
  private:
  bool _internal_has_fictionbook() const;

  public:
  void clear_fictionbook() ;
  const ::com::cps2004::FictionBook& fictionbook() const;
  PROTOBUF_NODISCARD ::com::cps2004::FictionBook* release_fictionbook();
  ::com::cps2004::FictionBook* mutable_fictionbook();
  void set_allocated_fictionbook(::com::cps2004::FictionBook* value);
  void unsafe_arena_set_allocated_fictionbook(::com::cps2004::FictionBook* value);
  ::com::cps2004::FictionBook* unsafe_arena_release_fictionbook();

  private:
  const ::com::cps2004::FictionBook& _internal_fictionbook() const;
  ::com::cps2004::FictionBook* _internal_mutable_fictionbook();

  public:
  // .com.cps2004.Textbook textbook = 2;
  bool has_textbook() const;
  private:
  bool _internal_has_textbook() const;

  public:
  void clear_textbook() ;
  const ::com::cps2004::Textbook& textbook() const;
  PROTOBUF_NODISCARD ::com::cps2004::Textbook* release_textbook();
  ::com::cps2004::Textbook* mutable_textbook();
  void set_allocated_textbook(::com::cps2004::Textbook* value);
  void unsafe_arena_set_allocated_textbook(::com::cps2004::Textbook* value);
  ::com::cps2004::Textbook* unsafe_arena_release_textbook();

  private:
  const ::com::cps2004::Textbook& _internal_textbook() const;
  ::com::cps2004::Textbook* _internal_mutable_textbook();

  public:
  void clear_book_type();
  BookTypeCase book_type_case() const;
  // @@protoc_insertion_point(class_scope:com.cps2004.Book)
 private:
  class _Internal;
  void set_has_fictionbook();
  void set_has_textbook();

  inline bool has_book_type() const;
  inline void clear_has_book_type();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 6, 3,
      40, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr publisher_;
    ::google::protobuf::internal::ArenaStringPtr author_;
    ::com::cps2004::Product* product_;
    ::int32_t pages_;
    union BookTypeUnion {
      constexpr BookTypeUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::com::cps2004::FictionBook* fictionbook_;
      ::com::cps2004::Textbook* textbook_;
    } book_type_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_5fstructures_2eproto;
};// -------------------------------------------------------------------

class Camera final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.cps2004.Camera) */ {
 public:
  inline Camera() : Camera(nullptr) {}
  ~Camera() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Camera(::google::protobuf::internal::ConstantInitialized);

  inline Camera(const Camera& from)
      : Camera(nullptr, from) {}
  Camera(Camera&& from) noexcept
    : Camera() {
    *this = ::std::move(from);
  }

  inline Camera& operator=(const Camera& from) {
    CopyFrom(from);
    return *this;
  }
  inline Camera& operator=(Camera&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Camera& default_instance() {
    return *internal_default_instance();
  }
  static inline const Camera* internal_default_instance() {
    return reinterpret_cast<const Camera*>(
               &_Camera_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Camera& a, Camera& b) {
    a.Swap(&b);
  }
  inline void Swap(Camera* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Camera* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Camera* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Camera>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Camera& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Camera& from) {
    Camera::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Camera* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.cps2004.Camera";
  }
  protected:
  explicit Camera(::google::protobuf::Arena* arena);
  Camera(::google::protobuf::Arena* arena, const Camera& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kElectronicsFieldNumber = 1,
    kMegaPixelsFieldNumber = 2,
    kZoomFieldNumber = 3,
    kWirelessConnectivityFieldNumber = 4,
  };
  // .com.cps2004.Electronics electronics = 1;
  bool has_electronics() const;
  void clear_electronics() ;
  const ::com::cps2004::Electronics& electronics() const;
  PROTOBUF_NODISCARD ::com::cps2004::Electronics* release_electronics();
  ::com::cps2004::Electronics* mutable_electronics();
  void set_allocated_electronics(::com::cps2004::Electronics* value);
  void unsafe_arena_set_allocated_electronics(::com::cps2004::Electronics* value);
  ::com::cps2004::Electronics* unsafe_arena_release_electronics();

  private:
  const ::com::cps2004::Electronics& _internal_electronics() const;
  ::com::cps2004::Electronics* _internal_mutable_electronics();

  public:
  // double megaPixels = 2;
  void clear_megapixels() ;
  double megapixels() const;
  void set_megapixels(double value);

  private:
  double _internal_megapixels() const;
  void _internal_set_megapixels(double value);

  public:
  // int32 zoom = 3;
  void clear_zoom() ;
  ::int32_t zoom() const;
  void set_zoom(::int32_t value);

  private:
  ::int32_t _internal_zoom() const;
  void _internal_set_zoom(::int32_t value);

  public:
  // bool wirelessConnectivity = 4;
  void clear_wirelessconnectivity() ;
  bool wirelessconnectivity() const;
  void set_wirelessconnectivity(bool value);

  private:
  bool _internal_wirelessconnectivity() const;
  void _internal_set_wirelessconnectivity(bool value);

  public:
  // @@protoc_insertion_point(class_scope:com.cps2004.Camera)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::com::cps2004::Electronics* electronics_;
    double megapixels_;
    ::int32_t zoom_;
    bool wirelessconnectivity_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_5fstructures_2eproto;
};// -------------------------------------------------------------------

class Chair final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.cps2004.Chair) */ {
 public:
  inline Chair() : Chair(nullptr) {}
  ~Chair() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Chair(::google::protobuf::internal::ConstantInitialized);

  inline Chair(const Chair& from)
      : Chair(nullptr, from) {}
  Chair(Chair&& from) noexcept
    : Chair() {
    *this = ::std::move(from);
  }

  inline Chair& operator=(const Chair& from) {
    CopyFrom(from);
    return *this;
  }
  inline Chair& operator=(Chair&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Chair& default_instance() {
    return *internal_default_instance();
  }
  static inline const Chair* internal_default_instance() {
    return reinterpret_cast<const Chair*>(
               &_Chair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(Chair& a, Chair& b) {
    a.Swap(&b);
  }
  inline void Swap(Chair* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Chair* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Chair* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Chair>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Chair& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Chair& from) {
    Chair::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Chair* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.cps2004.Chair";
  }
  protected:
  explicit Chair(::google::protobuf::Arena* arena);
  Chair(::google::protobuf::Arena* arena, const Chair& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFurnitureFieldNumber = 1,
    kSeatLengthFieldNumber = 2,
    kArmRestsFieldNumber = 3,
  };
  // .com.cps2004.Furniture furniture = 1;
  bool has_furniture() const;
  void clear_furniture() ;
  const ::com::cps2004::Furniture& furniture() const;
  PROTOBUF_NODISCARD ::com::cps2004::Furniture* release_furniture();
  ::com::cps2004::Furniture* mutable_furniture();
  void set_allocated_furniture(::com::cps2004::Furniture* value);
  void unsafe_arena_set_allocated_furniture(::com::cps2004::Furniture* value);
  ::com::cps2004::Furniture* unsafe_arena_release_furniture();

  private:
  const ::com::cps2004::Furniture& _internal_furniture() const;
  ::com::cps2004::Furniture* _internal_mutable_furniture();

  public:
  // double seatLength = 2;
  void clear_seatlength() ;
  double seatlength() const;
  void set_seatlength(double value);

  private:
  double _internal_seatlength() const;
  void _internal_set_seatlength(double value);

  public:
  // bool armRests = 3;
  void clear_armrests() ;
  bool armrests() const;
  void set_armrests(bool value);

  private:
  bool _internal_armrests() const;
  void _internal_set_armrests(bool value);

  public:
  // @@protoc_insertion_point(class_scope:com.cps2004.Chair)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::com::cps2004::Furniture* furniture_;
    double seatlength_;
    bool armrests_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_5fstructures_2eproto;
};// -------------------------------------------------------------------

class Clothes final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.cps2004.Clothes) */ {
 public:
  inline Clothes() : Clothes(nullptr) {}
  ~Clothes() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Clothes(::google::protobuf::internal::ConstantInitialized);

  inline Clothes(const Clothes& from)
      : Clothes(nullptr, from) {}
  Clothes(Clothes&& from) noexcept
    : Clothes() {
    *this = ::std::move(from);
  }

  inline Clothes& operator=(const Clothes& from) {
    CopyFrom(from);
    return *this;
  }
  inline Clothes& operator=(Clothes&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Clothes& default_instance() {
    return *internal_default_instance();
  }
  enum ClothesTypeCase {
    kPants = 1,
    kTShirt = 2,
    CLOTHES_TYPE_NOT_SET = 0,
  };

  static inline const Clothes* internal_default_instance() {
    return reinterpret_cast<const Clothes*>(
               &_Clothes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(Clothes& a, Clothes& b) {
    a.Swap(&b);
  }
  inline void Swap(Clothes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Clothes* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Clothes* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Clothes>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Clothes& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Clothes& from) {
    Clothes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Clothes* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.cps2004.Clothes";
  }
  protected:
  explicit Clothes(::google::protobuf::Arena* arena);
  Clothes(::google::protobuf::Arena* arena, const Clothes& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSizeFieldNumber = 4,
    kBrandFieldNumber = 5,
    kMaterialFieldNumber = 6,
    kProductFieldNumber = 3,
    kPantsFieldNumber = 1,
    kTShirtFieldNumber = 2,
  };
  // string size = 4;
  void clear_size() ;
  const std::string& size() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_size(Arg_&& arg, Args_... args);
  std::string* mutable_size();
  PROTOBUF_NODISCARD std::string* release_size();
  void set_allocated_size(std::string* value);

  private:
  const std::string& _internal_size() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_size(
      const std::string& value);
  std::string* _internal_mutable_size();

  public:
  // string brand = 5;
  void clear_brand() ;
  const std::string& brand() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_brand(Arg_&& arg, Args_... args);
  std::string* mutable_brand();
  PROTOBUF_NODISCARD std::string* release_brand();
  void set_allocated_brand(std::string* value);

  private:
  const std::string& _internal_brand() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_brand(
      const std::string& value);
  std::string* _internal_mutable_brand();

  public:
  // string material = 6;
  void clear_material() ;
  const std::string& material() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_material(Arg_&& arg, Args_... args);
  std::string* mutable_material();
  PROTOBUF_NODISCARD std::string* release_material();
  void set_allocated_material(std::string* value);

  private:
  const std::string& _internal_material() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_material(
      const std::string& value);
  std::string* _internal_mutable_material();

  public:
  // .com.cps2004.Product product = 3;
  bool has_product() const;
  void clear_product() ;
  const ::com::cps2004::Product& product() const;
  PROTOBUF_NODISCARD ::com::cps2004::Product* release_product();
  ::com::cps2004::Product* mutable_product();
  void set_allocated_product(::com::cps2004::Product* value);
  void unsafe_arena_set_allocated_product(::com::cps2004::Product* value);
  ::com::cps2004::Product* unsafe_arena_release_product();

  private:
  const ::com::cps2004::Product& _internal_product() const;
  ::com::cps2004::Product* _internal_mutable_product();

  public:
  // .com.cps2004.Pants pants = 1;
  bool has_pants() const;
  private:
  bool _internal_has_pants() const;

  public:
  void clear_pants() ;
  const ::com::cps2004::Pants& pants() const;
  PROTOBUF_NODISCARD ::com::cps2004::Pants* release_pants();
  ::com::cps2004::Pants* mutable_pants();
  void set_allocated_pants(::com::cps2004::Pants* value);
  void unsafe_arena_set_allocated_pants(::com::cps2004::Pants* value);
  ::com::cps2004::Pants* unsafe_arena_release_pants();

  private:
  const ::com::cps2004::Pants& _internal_pants() const;
  ::com::cps2004::Pants* _internal_mutable_pants();

  public:
  // .com.cps2004.TShirt tShirt = 2;
  bool has_tshirt() const;
  private:
  bool _internal_has_tshirt() const;

  public:
  void clear_tshirt() ;
  const ::com::cps2004::TShirt& tshirt() const;
  PROTOBUF_NODISCARD ::com::cps2004::TShirt* release_tshirt();
  ::com::cps2004::TShirt* mutable_tshirt();
  void set_allocated_tshirt(::com::cps2004::TShirt* value);
  void unsafe_arena_set_allocated_tshirt(::com::cps2004::TShirt* value);
  ::com::cps2004::TShirt* unsafe_arena_release_tshirt();

  private:
  const ::com::cps2004::TShirt& _internal_tshirt() const;
  ::com::cps2004::TShirt* _internal_mutable_tshirt();

  public:
  void clear_clothes_type();
  ClothesTypeCase clothes_type_case() const;
  // @@protoc_insertion_point(class_scope:com.cps2004.Clothes)
 private:
  class _Internal;
  void set_has_pants();
  void set_has_tshirt();

  inline bool has_clothes_type() const;
  inline void clear_has_clothes_type();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 6, 3,
      45, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr size_;
    ::google::protobuf::internal::ArenaStringPtr brand_;
    ::google::protobuf::internal::ArenaStringPtr material_;
    ::com::cps2004::Product* product_;
    union ClothesTypeUnion {
      constexpr ClothesTypeUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::com::cps2004::Pants* pants_;
      ::com::cps2004::TShirt* tshirt_;
    } clothes_type_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_5fstructures_2eproto;
};// -------------------------------------------------------------------

class Electronics final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.cps2004.Electronics) */ {
 public:
  inline Electronics() : Electronics(nullptr) {}
  ~Electronics() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Electronics(::google::protobuf::internal::ConstantInitialized);

  inline Electronics(const Electronics& from)
      : Electronics(nullptr, from) {}
  Electronics(Electronics&& from) noexcept
    : Electronics() {
    *this = ::std::move(from);
  }

  inline Electronics& operator=(const Electronics& from) {
    CopyFrom(from);
    return *this;
  }
  inline Electronics& operator=(Electronics&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Electronics& default_instance() {
    return *internal_default_instance();
  }
  enum ElectronicsTypeCase {
    kCamera = 1,
    kLaptop = 2,
    ELECTRONICS_TYPE_NOT_SET = 0,
  };

  static inline const Electronics* internal_default_instance() {
    return reinterpret_cast<const Electronics*>(
               &_Electronics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Electronics& a, Electronics& b) {
    a.Swap(&b);
  }
  inline void Swap(Electronics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Electronics* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Electronics* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Electronics>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Electronics& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Electronics& from) {
    Electronics::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Electronics* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.cps2004.Electronics";
  }
  protected:
  explicit Electronics(::google::protobuf::Arena* arena);
  Electronics(::google::protobuf::Arena* arena, const Electronics& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kManufacturerFieldNumber = 4,
    kProductFieldNumber = 3,
    kWarrantyFieldNumber = 5,
    kCameraFieldNumber = 1,
    kLaptopFieldNumber = 2,
  };
  // string manufacturer = 4;
  void clear_manufacturer() ;
  const std::string& manufacturer() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_manufacturer(Arg_&& arg, Args_... args);
  std::string* mutable_manufacturer();
  PROTOBUF_NODISCARD std::string* release_manufacturer();
  void set_allocated_manufacturer(std::string* value);

  private:
  const std::string& _internal_manufacturer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_manufacturer(
      const std::string& value);
  std::string* _internal_mutable_manufacturer();

  public:
  // .com.cps2004.Product product = 3;
  bool has_product() const;
  void clear_product() ;
  const ::com::cps2004::Product& product() const;
  PROTOBUF_NODISCARD ::com::cps2004::Product* release_product();
  ::com::cps2004::Product* mutable_product();
  void set_allocated_product(::com::cps2004::Product* value);
  void unsafe_arena_set_allocated_product(::com::cps2004::Product* value);
  ::com::cps2004::Product* unsafe_arena_release_product();

  private:
  const ::com::cps2004::Product& _internal_product() const;
  ::com::cps2004::Product* _internal_mutable_product();

  public:
  // int32 warranty = 5;
  void clear_warranty() ;
  ::int32_t warranty() const;
  void set_warranty(::int32_t value);

  private:
  ::int32_t _internal_warranty() const;
  void _internal_set_warranty(::int32_t value);

  public:
  // .com.cps2004.Camera camera = 1;
  bool has_camera() const;
  private:
  bool _internal_has_camera() const;

  public:
  void clear_camera() ;
  const ::com::cps2004::Camera& camera() const;
  PROTOBUF_NODISCARD ::com::cps2004::Camera* release_camera();
  ::com::cps2004::Camera* mutable_camera();
  void set_allocated_camera(::com::cps2004::Camera* value);
  void unsafe_arena_set_allocated_camera(::com::cps2004::Camera* value);
  ::com::cps2004::Camera* unsafe_arena_release_camera();

  private:
  const ::com::cps2004::Camera& _internal_camera() const;
  ::com::cps2004::Camera* _internal_mutable_camera();

  public:
  // .com.cps2004.Laptop laptop = 2;
  bool has_laptop() const;
  private:
  bool _internal_has_laptop() const;

  public:
  void clear_laptop() ;
  const ::com::cps2004::Laptop& laptop() const;
  PROTOBUF_NODISCARD ::com::cps2004::Laptop* release_laptop();
  ::com::cps2004::Laptop* mutable_laptop();
  void set_allocated_laptop(::com::cps2004::Laptop* value);
  void unsafe_arena_set_allocated_laptop(::com::cps2004::Laptop* value);
  ::com::cps2004::Laptop* unsafe_arena_release_laptop();

  private:
  const ::com::cps2004::Laptop& _internal_laptop() const;
  ::com::cps2004::Laptop* _internal_mutable_laptop();

  public:
  void clear_electronics_type();
  ElectronicsTypeCase electronics_type_case() const;
  // @@protoc_insertion_point(class_scope:com.cps2004.Electronics)
 private:
  class _Internal;
  void set_has_camera();
  void set_has_laptop();

  inline bool has_electronics_type() const;
  inline void clear_has_electronics_type();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 5, 3,
      44, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr manufacturer_;
    ::com::cps2004::Product* product_;
    ::int32_t warranty_;
    union ElectronicsTypeUnion {
      constexpr ElectronicsTypeUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::com::cps2004::Camera* camera_;
      ::com::cps2004::Laptop* laptop_;
    } electronics_type_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_5fstructures_2eproto;
};// -------------------------------------------------------------------

class FictionBook final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.cps2004.FictionBook) */ {
 public:
  inline FictionBook() : FictionBook(nullptr) {}
  ~FictionBook() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FictionBook(::google::protobuf::internal::ConstantInitialized);

  inline FictionBook(const FictionBook& from)
      : FictionBook(nullptr, from) {}
  FictionBook(FictionBook&& from) noexcept
    : FictionBook() {
    *this = ::std::move(from);
  }

  inline FictionBook& operator=(const FictionBook& from) {
    CopyFrom(from);
    return *this;
  }
  inline FictionBook& operator=(FictionBook&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FictionBook& default_instance() {
    return *internal_default_instance();
  }
  static inline const FictionBook* internal_default_instance() {
    return reinterpret_cast<const FictionBook*>(
               &_FictionBook_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(FictionBook& a, FictionBook& b) {
    a.Swap(&b);
  }
  inline void Swap(FictionBook* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FictionBook* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FictionBook* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FictionBook>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FictionBook& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const FictionBook& from) {
    FictionBook::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(FictionBook* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.cps2004.FictionBook";
  }
  protected:
  explicit FictionBook(::google::protobuf::Arena* arena);
  FictionBook(::google::protobuf::Arena* arena, const FictionBook& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGenreFieldNumber = 2,
    kPublicationDateFieldNumber = 3,
    kBookFieldNumber = 1,
  };
  // string genre = 2;
  void clear_genre() ;
  const std::string& genre() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_genre(Arg_&& arg, Args_... args);
  std::string* mutable_genre();
  PROTOBUF_NODISCARD std::string* release_genre();
  void set_allocated_genre(std::string* value);

  private:
  const std::string& _internal_genre() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_genre(
      const std::string& value);
  std::string* _internal_mutable_genre();

  public:
  // string publicationDate = 3;
  void clear_publicationdate() ;
  const std::string& publicationdate() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_publicationdate(Arg_&& arg, Args_... args);
  std::string* mutable_publicationdate();
  PROTOBUF_NODISCARD std::string* release_publicationdate();
  void set_allocated_publicationdate(std::string* value);

  private:
  const std::string& _internal_publicationdate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_publicationdate(
      const std::string& value);
  std::string* _internal_mutable_publicationdate();

  public:
  // .com.cps2004.Book book = 1;
  bool has_book() const;
  void clear_book() ;
  const ::com::cps2004::Book& book() const;
  PROTOBUF_NODISCARD ::com::cps2004::Book* release_book();
  ::com::cps2004::Book* mutable_book();
  void set_allocated_book(::com::cps2004::Book* value);
  void unsafe_arena_set_allocated_book(::com::cps2004::Book* value);
  ::com::cps2004::Book* unsafe_arena_release_book();

  private:
  const ::com::cps2004::Book& _internal_book() const;
  ::com::cps2004::Book* _internal_mutable_book();

  public:
  // @@protoc_insertion_point(class_scope:com.cps2004.FictionBook)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      52, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr genre_;
    ::google::protobuf::internal::ArenaStringPtr publicationdate_;
    ::com::cps2004::Book* book_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_5fstructures_2eproto;
};// -------------------------------------------------------------------

class Food final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.cps2004.Food) */ {
 public:
  inline Food() : Food(nullptr) {}
  ~Food() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Food(::google::protobuf::internal::ConstantInitialized);

  inline Food(const Food& from)
      : Food(nullptr, from) {}
  Food(Food&& from) noexcept
    : Food() {
    *this = ::std::move(from);
  }

  inline Food& operator=(const Food& from) {
    CopyFrom(from);
    return *this;
  }
  inline Food& operator=(Food&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Food& default_instance() {
    return *internal_default_instance();
  }
  enum FoodTypeCase {
    kFruit = 1,
    kPremadeLunch = 2,
    FOOD_TYPE_NOT_SET = 0,
  };

  static inline const Food* internal_default_instance() {
    return reinterpret_cast<const Food*>(
               &_Food_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Food& a, Food& b) {
    a.Swap(&b);
  }
  inline void Swap(Food* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Food* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Food* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Food>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Food& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Food& from) {
    Food::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Food* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.cps2004.Food";
  }
  protected:
  explicit Food(::google::protobuf::Arena* arena);
  Food(::google::protobuf::Arena* arena, const Food& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExpirationDateFieldNumber = 5,
    kProductFieldNumber = 3,
    kWeightFieldNumber = 4,
    kFruitFieldNumber = 1,
    kPremadeLunchFieldNumber = 2,
  };
  // string expirationDate = 5;
  void clear_expirationdate() ;
  const std::string& expirationdate() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_expirationdate(Arg_&& arg, Args_... args);
  std::string* mutable_expirationdate();
  PROTOBUF_NODISCARD std::string* release_expirationdate();
  void set_allocated_expirationdate(std::string* value);

  private:
  const std::string& _internal_expirationdate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_expirationdate(
      const std::string& value);
  std::string* _internal_mutable_expirationdate();

  public:
  // .com.cps2004.Product product = 3;
  bool has_product() const;
  void clear_product() ;
  const ::com::cps2004::Product& product() const;
  PROTOBUF_NODISCARD ::com::cps2004::Product* release_product();
  ::com::cps2004::Product* mutable_product();
  void set_allocated_product(::com::cps2004::Product* value);
  void unsafe_arena_set_allocated_product(::com::cps2004::Product* value);
  ::com::cps2004::Product* unsafe_arena_release_product();

  private:
  const ::com::cps2004::Product& _internal_product() const;
  ::com::cps2004::Product* _internal_mutable_product();

  public:
  // double weight = 4;
  void clear_weight() ;
  double weight() const;
  void set_weight(double value);

  private:
  double _internal_weight() const;
  void _internal_set_weight(double value);

  public:
  // .com.cps2004.Fruit fruit = 1;
  bool has_fruit() const;
  private:
  bool _internal_has_fruit() const;

  public:
  void clear_fruit() ;
  const ::com::cps2004::Fruit& fruit() const;
  PROTOBUF_NODISCARD ::com::cps2004::Fruit* release_fruit();
  ::com::cps2004::Fruit* mutable_fruit();
  void set_allocated_fruit(::com::cps2004::Fruit* value);
  void unsafe_arena_set_allocated_fruit(::com::cps2004::Fruit* value);
  ::com::cps2004::Fruit* unsafe_arena_release_fruit();

  private:
  const ::com::cps2004::Fruit& _internal_fruit() const;
  ::com::cps2004::Fruit* _internal_mutable_fruit();

  public:
  // .com.cps2004.PremadeLunch premadeLunch = 2;
  bool has_premadelunch() const;
  private:
  bool _internal_has_premadelunch() const;

  public:
  void clear_premadelunch() ;
  const ::com::cps2004::PremadeLunch& premadelunch() const;
  PROTOBUF_NODISCARD ::com::cps2004::PremadeLunch* release_premadelunch();
  ::com::cps2004::PremadeLunch* mutable_premadelunch();
  void set_allocated_premadelunch(::com::cps2004::PremadeLunch* value);
  void unsafe_arena_set_allocated_premadelunch(::com::cps2004::PremadeLunch* value);
  ::com::cps2004::PremadeLunch* unsafe_arena_release_premadelunch();

  private:
  const ::com::cps2004::PremadeLunch& _internal_premadelunch() const;
  ::com::cps2004::PremadeLunch* _internal_mutable_premadelunch();

  public:
  void clear_food_type();
  FoodTypeCase food_type_case() const;
  // @@protoc_insertion_point(class_scope:com.cps2004.Food)
 private:
  class _Internal;
  void set_has_fruit();
  void set_has_premadelunch();

  inline bool has_food_type() const;
  inline void clear_has_food_type();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 5, 3,
      39, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr expirationdate_;
    ::com::cps2004::Product* product_;
    double weight_;
    union FoodTypeUnion {
      constexpr FoodTypeUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::com::cps2004::Fruit* fruit_;
      ::com::cps2004::PremadeLunch* premadelunch_;
    } food_type_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_5fstructures_2eproto;
};// -------------------------------------------------------------------

class Fruit final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.cps2004.Fruit) */ {
 public:
  inline Fruit() : Fruit(nullptr) {}
  ~Fruit() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Fruit(::google::protobuf::internal::ConstantInitialized);

  inline Fruit(const Fruit& from)
      : Fruit(nullptr, from) {}
  Fruit(Fruit&& from) noexcept
    : Fruit() {
    *this = ::std::move(from);
  }

  inline Fruit& operator=(const Fruit& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fruit& operator=(Fruit&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Fruit& default_instance() {
    return *internal_default_instance();
  }
  static inline const Fruit* internal_default_instance() {
    return reinterpret_cast<const Fruit*>(
               &_Fruit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Fruit& a, Fruit& b) {
    a.Swap(&b);
  }
  inline void Swap(Fruit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Fruit* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Fruit* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Fruit>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Fruit& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Fruit& from) {
    Fruit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Fruit* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.cps2004.Fruit";
  }
  protected:
  explicit Fruit(::google::protobuf::Arena* arena);
  Fruit(::google::protobuf::Arena* arena, const Fruit& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCountryOfOriginFieldNumber = 2,
    kTypeFieldNumber = 3,
    kFoodFieldNumber = 1,
    kOrganicFieldNumber = 4,
  };
  // string countryOfOrigin = 2;
  void clear_countryoforigin() ;
  const std::string& countryoforigin() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_countryoforigin(Arg_&& arg, Args_... args);
  std::string* mutable_countryoforigin();
  PROTOBUF_NODISCARD std::string* release_countryoforigin();
  void set_allocated_countryoforigin(std::string* value);

  private:
  const std::string& _internal_countryoforigin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_countryoforigin(
      const std::string& value);
  std::string* _internal_mutable_countryoforigin();

  public:
  // string type = 3;
  void clear_type() ;
  const std::string& type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_type(Arg_&& arg, Args_... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* value);

  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(
      const std::string& value);
  std::string* _internal_mutable_type();

  public:
  // .com.cps2004.Food food = 1;
  bool has_food() const;
  void clear_food() ;
  const ::com::cps2004::Food& food() const;
  PROTOBUF_NODISCARD ::com::cps2004::Food* release_food();
  ::com::cps2004::Food* mutable_food();
  void set_allocated_food(::com::cps2004::Food* value);
  void unsafe_arena_set_allocated_food(::com::cps2004::Food* value);
  ::com::cps2004::Food* unsafe_arena_release_food();

  private:
  const ::com::cps2004::Food& _internal_food() const;
  ::com::cps2004::Food* _internal_mutable_food();

  public:
  // bool organic = 4;
  void clear_organic() ;
  bool organic() const;
  void set_organic(bool value);

  private:
  bool _internal_organic() const;
  void _internal_set_organic(bool value);

  public:
  // @@protoc_insertion_point(class_scope:com.cps2004.Fruit)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      45, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr countryoforigin_;
    ::google::protobuf::internal::ArenaStringPtr type_;
    ::com::cps2004::Food* food_;
    bool organic_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_5fstructures_2eproto;
};// -------------------------------------------------------------------

class Furniture final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.cps2004.Furniture) */ {
 public:
  inline Furniture() : Furniture(nullptr) {}
  ~Furniture() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Furniture(::google::protobuf::internal::ConstantInitialized);

  inline Furniture(const Furniture& from)
      : Furniture(nullptr, from) {}
  Furniture(Furniture&& from) noexcept
    : Furniture() {
    *this = ::std::move(from);
  }

  inline Furniture& operator=(const Furniture& from) {
    CopyFrom(from);
    return *this;
  }
  inline Furniture& operator=(Furniture&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Furniture& default_instance() {
    return *internal_default_instance();
  }
  enum FurnitureTypeCase {
    kTable = 1,
    kChair = 2,
    FURNITURE_TYPE_NOT_SET = 0,
  };

  static inline const Furniture* internal_default_instance() {
    return reinterpret_cast<const Furniture*>(
               &_Furniture_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(Furniture& a, Furniture& b) {
    a.Swap(&b);
  }
  inline void Swap(Furniture* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Furniture* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Furniture* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Furniture>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Furniture& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Furniture& from) {
    Furniture::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Furniture* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.cps2004.Furniture";
  }
  protected:
  explicit Furniture(::google::protobuf::Arena* arena);
  Furniture(::google::protobuf::Arena* arena, const Furniture& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaterialFieldNumber = 4,
    kDimensionsFieldNumber = 5,
    kProductFieldNumber = 3,
    kTableFieldNumber = 1,
    kChairFieldNumber = 2,
  };
  // string material = 4;
  void clear_material() ;
  const std::string& material() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_material(Arg_&& arg, Args_... args);
  std::string* mutable_material();
  PROTOBUF_NODISCARD std::string* release_material();
  void set_allocated_material(std::string* value);

  private:
  const std::string& _internal_material() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_material(
      const std::string& value);
  std::string* _internal_mutable_material();

  public:
  // string dimensions = 5;
  void clear_dimensions() ;
  const std::string& dimensions() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dimensions(Arg_&& arg, Args_... args);
  std::string* mutable_dimensions();
  PROTOBUF_NODISCARD std::string* release_dimensions();
  void set_allocated_dimensions(std::string* value);

  private:
  const std::string& _internal_dimensions() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dimensions(
      const std::string& value);
  std::string* _internal_mutable_dimensions();

  public:
  // .com.cps2004.Product product = 3;
  bool has_product() const;
  void clear_product() ;
  const ::com::cps2004::Product& product() const;
  PROTOBUF_NODISCARD ::com::cps2004::Product* release_product();
  ::com::cps2004::Product* mutable_product();
  void set_allocated_product(::com::cps2004::Product* value);
  void unsafe_arena_set_allocated_product(::com::cps2004::Product* value);
  ::com::cps2004::Product* unsafe_arena_release_product();

  private:
  const ::com::cps2004::Product& _internal_product() const;
  ::com::cps2004::Product* _internal_mutable_product();

  public:
  // .com.cps2004.Table table = 1;
  bool has_table() const;
  private:
  bool _internal_has_table() const;

  public:
  void clear_table() ;
  const ::com::cps2004::Table& table() const;
  PROTOBUF_NODISCARD ::com::cps2004::Table* release_table();
  ::com::cps2004::Table* mutable_table();
  void set_allocated_table(::com::cps2004::Table* value);
  void unsafe_arena_set_allocated_table(::com::cps2004::Table* value);
  ::com::cps2004::Table* unsafe_arena_release_table();

  private:
  const ::com::cps2004::Table& _internal_table() const;
  ::com::cps2004::Table* _internal_mutable_table();

  public:
  // .com.cps2004.Chair chair = 2;
  bool has_chair() const;
  private:
  bool _internal_has_chair() const;

  public:
  void clear_chair() ;
  const ::com::cps2004::Chair& chair() const;
  PROTOBUF_NODISCARD ::com::cps2004::Chair* release_chair();
  ::com::cps2004::Chair* mutable_chair();
  void set_allocated_chair(::com::cps2004::Chair* value);
  void unsafe_arena_set_allocated_chair(::com::cps2004::Chair* value);
  ::com::cps2004::Chair* unsafe_arena_release_chair();

  private:
  const ::com::cps2004::Chair& _internal_chair() const;
  ::com::cps2004::Chair* _internal_mutable_chair();

  public:
  void clear_furniture_type();
  FurnitureTypeCase furniture_type_case() const;
  // @@protoc_insertion_point(class_scope:com.cps2004.Furniture)
 private:
  class _Internal;
  void set_has_table();
  void set_has_chair();

  inline bool has_furniture_type() const;
  inline void clear_has_furniture_type();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 5, 3,
      48, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr material_;
    ::google::protobuf::internal::ArenaStringPtr dimensions_;
    ::com::cps2004::Product* product_;
    union FurnitureTypeUnion {
      constexpr FurnitureTypeUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::com::cps2004::Table* table_;
      ::com::cps2004::Chair* chair_;
    } furniture_type_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_5fstructures_2eproto;
};// -------------------------------------------------------------------

class Laptop final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.cps2004.Laptop) */ {
 public:
  inline Laptop() : Laptop(nullptr) {}
  ~Laptop() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Laptop(::google::protobuf::internal::ConstantInitialized);

  inline Laptop(const Laptop& from)
      : Laptop(nullptr, from) {}
  Laptop(Laptop&& from) noexcept
    : Laptop() {
    *this = ::std::move(from);
  }

  inline Laptop& operator=(const Laptop& from) {
    CopyFrom(from);
    return *this;
  }
  inline Laptop& operator=(Laptop&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Laptop& default_instance() {
    return *internal_default_instance();
  }
  static inline const Laptop* internal_default_instance() {
    return reinterpret_cast<const Laptop*>(
               &_Laptop_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Laptop& a, Laptop& b) {
    a.Swap(&b);
  }
  inline void Swap(Laptop* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Laptop* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Laptop* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Laptop>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Laptop& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Laptop& from) {
    Laptop::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Laptop* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.cps2004.Laptop";
  }
  protected:
  explicit Laptop(::google::protobuf::Arena* arena);
  Laptop(::google::protobuf::Arena* arena, const Laptop& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOperatingSystemFieldNumber = 3,
    kElectronicsFieldNumber = 1,
    kScreenSizeFieldNumber = 2,
    kRamFieldNumber = 4,
  };
  // string operatingSystem = 3;
  void clear_operatingsystem() ;
  const std::string& operatingsystem() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_operatingsystem(Arg_&& arg, Args_... args);
  std::string* mutable_operatingsystem();
  PROTOBUF_NODISCARD std::string* release_operatingsystem();
  void set_allocated_operatingsystem(std::string* value);

  private:
  const std::string& _internal_operatingsystem() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operatingsystem(
      const std::string& value);
  std::string* _internal_mutable_operatingsystem();

  public:
  // .com.cps2004.Electronics electronics = 1;
  bool has_electronics() const;
  void clear_electronics() ;
  const ::com::cps2004::Electronics& electronics() const;
  PROTOBUF_NODISCARD ::com::cps2004::Electronics* release_electronics();
  ::com::cps2004::Electronics* mutable_electronics();
  void set_allocated_electronics(::com::cps2004::Electronics* value);
  void unsafe_arena_set_allocated_electronics(::com::cps2004::Electronics* value);
  ::com::cps2004::Electronics* unsafe_arena_release_electronics();

  private:
  const ::com::cps2004::Electronics& _internal_electronics() const;
  ::com::cps2004::Electronics* _internal_mutable_electronics();

  public:
  // double screenSize = 2;
  void clear_screensize() ;
  double screensize() const;
  void set_screensize(double value);

  private:
  double _internal_screensize() const;
  void _internal_set_screensize(double value);

  public:
  // int32 ram = 4;
  void clear_ram() ;
  ::int32_t ram() const;
  void set_ram(::int32_t value);

  private:
  ::int32_t _internal_ram() const;
  void _internal_set_ram(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:com.cps2004.Laptop)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      42, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr operatingsystem_;
    ::com::cps2004::Electronics* electronics_;
    double screensize_;
    ::int32_t ram_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_5fstructures_2eproto;
};// -------------------------------------------------------------------

class Pants final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.cps2004.Pants) */ {
 public:
  inline Pants() : Pants(nullptr) {}
  ~Pants() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Pants(::google::protobuf::internal::ConstantInitialized);

  inline Pants(const Pants& from)
      : Pants(nullptr, from) {}
  Pants(Pants&& from) noexcept
    : Pants() {
    *this = ::std::move(from);
  }

  inline Pants& operator=(const Pants& from) {
    CopyFrom(from);
    return *this;
  }
  inline Pants& operator=(Pants&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Pants& default_instance() {
    return *internal_default_instance();
  }
  static inline const Pants* internal_default_instance() {
    return reinterpret_cast<const Pants*>(
               &_Pants_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(Pants& a, Pants& b) {
    a.Swap(&b);
  }
  inline void Swap(Pants* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Pants* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Pants* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Pants>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Pants& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Pants& from) {
    Pants::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Pants* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.cps2004.Pants";
  }
  protected:
  explicit Pants(::google::protobuf::Arena* arena);
  Pants(::google::protobuf::Arena* arena, const Pants& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClothesFieldNumber = 1,
    kInseamFieldNumber = 2,
    kWaistFieldNumber = 3,
  };
  // .com.cps2004.Clothes clothes = 1;
  bool has_clothes() const;
  void clear_clothes() ;
  const ::com::cps2004::Clothes& clothes() const;
  PROTOBUF_NODISCARD ::com::cps2004::Clothes* release_clothes();
  ::com::cps2004::Clothes* mutable_clothes();
  void set_allocated_clothes(::com::cps2004::Clothes* value);
  void unsafe_arena_set_allocated_clothes(::com::cps2004::Clothes* value);
  ::com::cps2004::Clothes* unsafe_arena_release_clothes();

  private:
  const ::com::cps2004::Clothes& _internal_clothes() const;
  ::com::cps2004::Clothes* _internal_mutable_clothes();

  public:
  // double inseam = 2;
  void clear_inseam() ;
  double inseam() const;
  void set_inseam(double value);

  private:
  double _internal_inseam() const;
  void _internal_set_inseam(double value);

  public:
  // double waist = 3;
  void clear_waist() ;
  double waist() const;
  void set_waist(double value);

  private:
  double _internal_waist() const;
  void _internal_set_waist(double value);

  public:
  // @@protoc_insertion_point(class_scope:com.cps2004.Pants)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::com::cps2004::Clothes* clothes_;
    double inseam_;
    double waist_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_5fstructures_2eproto;
};// -------------------------------------------------------------------

class PremadeLunch final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.cps2004.PremadeLunch) */ {
 public:
  inline PremadeLunch() : PremadeLunch(nullptr) {}
  ~PremadeLunch() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PremadeLunch(::google::protobuf::internal::ConstantInitialized);

  inline PremadeLunch(const PremadeLunch& from)
      : PremadeLunch(nullptr, from) {}
  PremadeLunch(PremadeLunch&& from) noexcept
    : PremadeLunch() {
    *this = ::std::move(from);
  }

  inline PremadeLunch& operator=(const PremadeLunch& from) {
    CopyFrom(from);
    return *this;
  }
  inline PremadeLunch& operator=(PremadeLunch&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PremadeLunch& default_instance() {
    return *internal_default_instance();
  }
  static inline const PremadeLunch* internal_default_instance() {
    return reinterpret_cast<const PremadeLunch*>(
               &_PremadeLunch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(PremadeLunch& a, PremadeLunch& b) {
    a.Swap(&b);
  }
  inline void Swap(PremadeLunch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PremadeLunch* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PremadeLunch* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PremadeLunch>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PremadeLunch& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PremadeLunch& from) {
    PremadeLunch::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PremadeLunch* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.cps2004.PremadeLunch";
  }
  protected:
  explicit PremadeLunch(::google::protobuf::Arena* arena);
  PremadeLunch(::google::protobuf::Arena* arena, const PremadeLunch& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIngredientsFieldNumber = 3,
    kAllergensFieldNumber = 4,
    kFoodFieldNumber = 1,
    kPerishableFieldNumber = 2,
  };
  // string ingredients = 3;
  void clear_ingredients() ;
  const std::string& ingredients() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ingredients(Arg_&& arg, Args_... args);
  std::string* mutable_ingredients();
  PROTOBUF_NODISCARD std::string* release_ingredients();
  void set_allocated_ingredients(std::string* value);

  private:
  const std::string& _internal_ingredients() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ingredients(
      const std::string& value);
  std::string* _internal_mutable_ingredients();

  public:
  // string allergens = 4;
  void clear_allergens() ;
  const std::string& allergens() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_allergens(Arg_&& arg, Args_... args);
  std::string* mutable_allergens();
  PROTOBUF_NODISCARD std::string* release_allergens();
  void set_allocated_allergens(std::string* value);

  private:
  const std::string& _internal_allergens() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_allergens(
      const std::string& value);
  std::string* _internal_mutable_allergens();

  public:
  // .com.cps2004.Food food = 1;
  bool has_food() const;
  void clear_food() ;
  const ::com::cps2004::Food& food() const;
  PROTOBUF_NODISCARD ::com::cps2004::Food* release_food();
  ::com::cps2004::Food* mutable_food();
  void set_allocated_food(::com::cps2004::Food* value);
  void unsafe_arena_set_allocated_food(::com::cps2004::Food* value);
  ::com::cps2004::Food* unsafe_arena_release_food();

  private:
  const ::com::cps2004::Food& _internal_food() const;
  ::com::cps2004::Food* _internal_mutable_food();

  public:
  // bool perishable = 2;
  void clear_perishable() ;
  bool perishable() const;
  void set_perishable(bool value);

  private:
  bool _internal_perishable() const;
  void _internal_set_perishable(bool value);

  public:
  // @@protoc_insertion_point(class_scope:com.cps2004.PremadeLunch)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      53, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr ingredients_;
    ::google::protobuf::internal::ArenaStringPtr allergens_;
    ::com::cps2004::Food* food_;
    bool perishable_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_5fstructures_2eproto;
};// -------------------------------------------------------------------

class Product final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.cps2004.Product) */ {
 public:
  inline Product() : Product(nullptr) {}
  ~Product() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Product(::google::protobuf::internal::ConstantInitialized);

  inline Product(const Product& from)
      : Product(nullptr, from) {}
  Product(Product&& from) noexcept
    : Product() {
    *this = ::std::move(from);
  }

  inline Product& operator=(const Product& from) {
    CopyFrom(from);
    return *this;
  }
  inline Product& operator=(Product&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Product& default_instance() {
    return *internal_default_instance();
  }
  enum ProductTypeCase {
    kBook = 1,
    kElectronics = 2,
    kFood = 3,
    kClothes = 4,
    kFurniture = 5,
    kVideoGame = 6,
    PRODUCT_TYPE_NOT_SET = 0,
  };

  static inline const Product* internal_default_instance() {
    return reinterpret_cast<const Product*>(
               &_Product_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Product& a, Product& b) {
    a.Swap(&b);
  }
  inline void Swap(Product* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Product* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Product* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Product>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Product& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Product& from) {
    Product::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Product* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.cps2004.Product";
  }
  protected:
  explicit Product(::google::protobuf::Arena* arena);
  Product(::google::protobuf::Arena* arena, const Product& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 7,
    kSupplierFieldNumber = 11,
    kProductIDFieldNumber = 8,
    kPriceFieldNumber = 9,
    kQuantityFieldNumber = 10,
    kVolumeFieldNumber = 12,
    kBookFieldNumber = 1,
    kElectronicsFieldNumber = 2,
    kFoodFieldNumber = 3,
    kClothesFieldNumber = 4,
    kFurnitureFieldNumber = 5,
    kVideoGameFieldNumber = 6,
  };
  // string name = 7;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // .com.cps2004.Supplier supplier = 11;
  bool has_supplier() const;
  void clear_supplier() ;
  const ::com::cps2004::Supplier& supplier() const;
  PROTOBUF_NODISCARD ::com::cps2004::Supplier* release_supplier();
  ::com::cps2004::Supplier* mutable_supplier();
  void set_allocated_supplier(::com::cps2004::Supplier* value);
  void unsafe_arena_set_allocated_supplier(::com::cps2004::Supplier* value);
  ::com::cps2004::Supplier* unsafe_arena_release_supplier();

  private:
  const ::com::cps2004::Supplier& _internal_supplier() const;
  ::com::cps2004::Supplier* _internal_mutable_supplier();

  public:
  // int32 productID = 8;
  void clear_productid() ;
  ::int32_t productid() const;
  void set_productid(::int32_t value);

  private:
  ::int32_t _internal_productid() const;
  void _internal_set_productid(::int32_t value);

  public:
  // int32 price = 9;
  void clear_price() ;
  ::int32_t price() const;
  void set_price(::int32_t value);

  private:
  ::int32_t _internal_price() const;
  void _internal_set_price(::int32_t value);

  public:
  // int32 quantity = 10;
  void clear_quantity() ;
  ::int32_t quantity() const;
  void set_quantity(::int32_t value);

  private:
  ::int32_t _internal_quantity() const;
  void _internal_set_quantity(::int32_t value);

  public:
  // int32 volume = 12;
  void clear_volume() ;
  ::int32_t volume() const;
  void set_volume(::int32_t value);

  private:
  ::int32_t _internal_volume() const;
  void _internal_set_volume(::int32_t value);

  public:
  // .com.cps2004.Book book = 1;
  bool has_book() const;
  private:
  bool _internal_has_book() const;

  public:
  void clear_book() ;
  const ::com::cps2004::Book& book() const;
  PROTOBUF_NODISCARD ::com::cps2004::Book* release_book();
  ::com::cps2004::Book* mutable_book();
  void set_allocated_book(::com::cps2004::Book* value);
  void unsafe_arena_set_allocated_book(::com::cps2004::Book* value);
  ::com::cps2004::Book* unsafe_arena_release_book();

  private:
  const ::com::cps2004::Book& _internal_book() const;
  ::com::cps2004::Book* _internal_mutable_book();

  public:
  // .com.cps2004.Electronics electronics = 2;
  bool has_electronics() const;
  private:
  bool _internal_has_electronics() const;

  public:
  void clear_electronics() ;
  const ::com::cps2004::Electronics& electronics() const;
  PROTOBUF_NODISCARD ::com::cps2004::Electronics* release_electronics();
  ::com::cps2004::Electronics* mutable_electronics();
  void set_allocated_electronics(::com::cps2004::Electronics* value);
  void unsafe_arena_set_allocated_electronics(::com::cps2004::Electronics* value);
  ::com::cps2004::Electronics* unsafe_arena_release_electronics();

  private:
  const ::com::cps2004::Electronics& _internal_electronics() const;
  ::com::cps2004::Electronics* _internal_mutable_electronics();

  public:
  // .com.cps2004.Food food = 3;
  bool has_food() const;
  private:
  bool _internal_has_food() const;

  public:
  void clear_food() ;
  const ::com::cps2004::Food& food() const;
  PROTOBUF_NODISCARD ::com::cps2004::Food* release_food();
  ::com::cps2004::Food* mutable_food();
  void set_allocated_food(::com::cps2004::Food* value);
  void unsafe_arena_set_allocated_food(::com::cps2004::Food* value);
  ::com::cps2004::Food* unsafe_arena_release_food();

  private:
  const ::com::cps2004::Food& _internal_food() const;
  ::com::cps2004::Food* _internal_mutable_food();

  public:
  // .com.cps2004.Clothes clothes = 4;
  bool has_clothes() const;
  private:
  bool _internal_has_clothes() const;

  public:
  void clear_clothes() ;
  const ::com::cps2004::Clothes& clothes() const;
  PROTOBUF_NODISCARD ::com::cps2004::Clothes* release_clothes();
  ::com::cps2004::Clothes* mutable_clothes();
  void set_allocated_clothes(::com::cps2004::Clothes* value);
  void unsafe_arena_set_allocated_clothes(::com::cps2004::Clothes* value);
  ::com::cps2004::Clothes* unsafe_arena_release_clothes();

  private:
  const ::com::cps2004::Clothes& _internal_clothes() const;
  ::com::cps2004::Clothes* _internal_mutable_clothes();

  public:
  // .com.cps2004.Furniture furniture = 5;
  bool has_furniture() const;
  private:
  bool _internal_has_furniture() const;

  public:
  void clear_furniture() ;
  const ::com::cps2004::Furniture& furniture() const;
  PROTOBUF_NODISCARD ::com::cps2004::Furniture* release_furniture();
  ::com::cps2004::Furniture* mutable_furniture();
  void set_allocated_furniture(::com::cps2004::Furniture* value);
  void unsafe_arena_set_allocated_furniture(::com::cps2004::Furniture* value);
  ::com::cps2004::Furniture* unsafe_arena_release_furniture();

  private:
  const ::com::cps2004::Furniture& _internal_furniture() const;
  ::com::cps2004::Furniture* _internal_mutable_furniture();

  public:
  // .com.cps2004.VideoGame videoGame = 6;
  bool has_videogame() const;
  private:
  bool _internal_has_videogame() const;

  public:
  void clear_videogame() ;
  const ::com::cps2004::VideoGame& videogame() const;
  PROTOBUF_NODISCARD ::com::cps2004::VideoGame* release_videogame();
  ::com::cps2004::VideoGame* mutable_videogame();
  void set_allocated_videogame(::com::cps2004::VideoGame* value);
  void unsafe_arena_set_allocated_videogame(::com::cps2004::VideoGame* value);
  ::com::cps2004::VideoGame* unsafe_arena_release_videogame();

  private:
  const ::com::cps2004::VideoGame& _internal_videogame() const;
  ::com::cps2004::VideoGame* _internal_mutable_videogame();

  public:
  void clear_product_type();
  ProductTypeCase product_type_case() const;
  // @@protoc_insertion_point(class_scope:com.cps2004.Product)
 private:
  class _Internal;
  void set_has_book();
  void set_has_electronics();
  void set_has_food();
  void set_has_clothes();
  void set_has_furniture();
  void set_has_videogame();

  inline bool has_product_type() const;
  inline void clear_has_product_type();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 12, 7,
      40, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::com::cps2004::Supplier* supplier_;
    ::int32_t productid_;
    ::int32_t price_;
    ::int32_t quantity_;
    ::int32_t volume_;
    union ProductTypeUnion {
      constexpr ProductTypeUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::com::cps2004::Book* book_;
      ::com::cps2004::Electronics* electronics_;
      ::com::cps2004::Food* food_;
      ::com::cps2004::Clothes* clothes_;
      ::com::cps2004::Furniture* furniture_;
      ::com::cps2004::VideoGame* videogame_;
    } product_type_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_5fstructures_2eproto;
};// -------------------------------------------------------------------

class RPG final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.cps2004.RPG) */ {
 public:
  inline RPG() : RPG(nullptr) {}
  ~RPG() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RPG(::google::protobuf::internal::ConstantInitialized);

  inline RPG(const RPG& from)
      : RPG(nullptr, from) {}
  RPG(RPG&& from) noexcept
    : RPG() {
    *this = ::std::move(from);
  }

  inline RPG& operator=(const RPG& from) {
    CopyFrom(from);
    return *this;
  }
  inline RPG& operator=(RPG&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RPG& default_instance() {
    return *internal_default_instance();
  }
  static inline const RPG* internal_default_instance() {
    return reinterpret_cast<const RPG*>(
               &_RPG_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(RPG& a, RPG& b) {
    a.Swap(&b);
  }
  inline void Swap(RPG* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RPG* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RPG* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RPG>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RPG& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RPG& from) {
    RPG::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RPG* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.cps2004.RPG";
  }
  protected:
  explicit RPG(::google::protobuf::Arena* arena);
  RPG(::google::protobuf::Arena* arena, const RPG& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStoryFieldNumber = 2,
    kVideoGameFieldNumber = 1,
    kMultiplayerFieldNumber = 3,
  };
  // string story = 2;
  void clear_story() ;
  const std::string& story() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_story(Arg_&& arg, Args_... args);
  std::string* mutable_story();
  PROTOBUF_NODISCARD std::string* release_story();
  void set_allocated_story(std::string* value);

  private:
  const std::string& _internal_story() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_story(
      const std::string& value);
  std::string* _internal_mutable_story();

  public:
  // .com.cps2004.VideoGame videoGame = 1;
  bool has_videogame() const;
  void clear_videogame() ;
  const ::com::cps2004::VideoGame& videogame() const;
  PROTOBUF_NODISCARD ::com::cps2004::VideoGame* release_videogame();
  ::com::cps2004::VideoGame* mutable_videogame();
  void set_allocated_videogame(::com::cps2004::VideoGame* value);
  void unsafe_arena_set_allocated_videogame(::com::cps2004::VideoGame* value);
  ::com::cps2004::VideoGame* unsafe_arena_release_videogame();

  private:
  const ::com::cps2004::VideoGame& _internal_videogame() const;
  ::com::cps2004::VideoGame* _internal_mutable_videogame();

  public:
  // bool multiplayer = 3;
  void clear_multiplayer() ;
  bool multiplayer() const;
  void set_multiplayer(bool value);

  private:
  bool _internal_multiplayer() const;
  void _internal_set_multiplayer(bool value);

  public:
  // @@protoc_insertion_point(class_scope:com.cps2004.RPG)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      29, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr story_;
    ::com::cps2004::VideoGame* videogame_;
    bool multiplayer_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_5fstructures_2eproto;
};// -------------------------------------------------------------------

class TShirt final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.cps2004.TShirt) */ {
 public:
  inline TShirt() : TShirt(nullptr) {}
  ~TShirt() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TShirt(::google::protobuf::internal::ConstantInitialized);

  inline TShirt(const TShirt& from)
      : TShirt(nullptr, from) {}
  TShirt(TShirt&& from) noexcept
    : TShirt() {
    *this = ::std::move(from);
  }

  inline TShirt& operator=(const TShirt& from) {
    CopyFrom(from);
    return *this;
  }
  inline TShirt& operator=(TShirt&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TShirt& default_instance() {
    return *internal_default_instance();
  }
  static inline const TShirt* internal_default_instance() {
    return reinterpret_cast<const TShirt*>(
               &_TShirt_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(TShirt& a, TShirt& b) {
    a.Swap(&b);
  }
  inline void Swap(TShirt* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TShirt* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TShirt* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TShirt>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TShirt& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TShirt& from) {
    TShirt::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TShirt* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.cps2004.TShirt";
  }
  protected:
  explicit TShirt(::google::protobuf::Arena* arena);
  TShirt(::google::protobuf::Arena* arena, const TShirt& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCollarFieldNumber = 2,
    kClothesFieldNumber = 1,
    kGraphicsFieldNumber = 3,
  };
  // string collar = 2;
  void clear_collar() ;
  const std::string& collar() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_collar(Arg_&& arg, Args_... args);
  std::string* mutable_collar();
  PROTOBUF_NODISCARD std::string* release_collar();
  void set_allocated_collar(std::string* value);

  private:
  const std::string& _internal_collar() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_collar(
      const std::string& value);
  std::string* _internal_mutable_collar();

  public:
  // .com.cps2004.Clothes clothes = 1;
  bool has_clothes() const;
  void clear_clothes() ;
  const ::com::cps2004::Clothes& clothes() const;
  PROTOBUF_NODISCARD ::com::cps2004::Clothes* release_clothes();
  ::com::cps2004::Clothes* mutable_clothes();
  void set_allocated_clothes(::com::cps2004::Clothes* value);
  void unsafe_arena_set_allocated_clothes(::com::cps2004::Clothes* value);
  ::com::cps2004::Clothes* unsafe_arena_release_clothes();

  private:
  const ::com::cps2004::Clothes& _internal_clothes() const;
  ::com::cps2004::Clothes* _internal_mutable_clothes();

  public:
  // bool graphics = 3;
  void clear_graphics() ;
  bool graphics() const;
  void set_graphics(bool value);

  private:
  bool _internal_graphics() const;
  void _internal_set_graphics(bool value);

  public:
  // @@protoc_insertion_point(class_scope:com.cps2004.TShirt)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      33, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr collar_;
    ::com::cps2004::Clothes* clothes_;
    bool graphics_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_5fstructures_2eproto;
};// -------------------------------------------------------------------

class Table final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.cps2004.Table) */ {
 public:
  inline Table() : Table(nullptr) {}
  ~Table() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Table(::google::protobuf::internal::ConstantInitialized);

  inline Table(const Table& from)
      : Table(nullptr, from) {}
  Table(Table&& from) noexcept
    : Table() {
    *this = ::std::move(from);
  }

  inline Table& operator=(const Table& from) {
    CopyFrom(from);
    return *this;
  }
  inline Table& operator=(Table&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Table& default_instance() {
    return *internal_default_instance();
  }
  static inline const Table* internal_default_instance() {
    return reinterpret_cast<const Table*>(
               &_Table_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(Table& a, Table& b) {
    a.Swap(&b);
  }
  inline void Swap(Table* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Table* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Table* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Table>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Table& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Table& from) {
    Table::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Table* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.cps2004.Table";
  }
  protected:
  explicit Table(::google::protobuf::Arena* arena);
  Table(::google::protobuf::Arena* arena, const Table& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShapeFieldNumber = 3,
    kFurnitureFieldNumber = 1,
    kExtendableFieldNumber = 2,
    kNoOfLegsFieldNumber = 4,
  };
  // string shape = 3;
  void clear_shape() ;
  const std::string& shape() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_shape(Arg_&& arg, Args_... args);
  std::string* mutable_shape();
  PROTOBUF_NODISCARD std::string* release_shape();
  void set_allocated_shape(std::string* value);

  private:
  const std::string& _internal_shape() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_shape(
      const std::string& value);
  std::string* _internal_mutable_shape();

  public:
  // .com.cps2004.Furniture furniture = 1;
  bool has_furniture() const;
  void clear_furniture() ;
  const ::com::cps2004::Furniture& furniture() const;
  PROTOBUF_NODISCARD ::com::cps2004::Furniture* release_furniture();
  ::com::cps2004::Furniture* mutable_furniture();
  void set_allocated_furniture(::com::cps2004::Furniture* value);
  void unsafe_arena_set_allocated_furniture(::com::cps2004::Furniture* value);
  ::com::cps2004::Furniture* unsafe_arena_release_furniture();

  private:
  const ::com::cps2004::Furniture& _internal_furniture() const;
  ::com::cps2004::Furniture* _internal_mutable_furniture();

  public:
  // bool extendable = 2;
  void clear_extendable() ;
  bool extendable() const;
  void set_extendable(bool value);

  private:
  bool _internal_extendable() const;
  void _internal_set_extendable(bool value);

  public:
  // int32 noOfLegs = 4;
  void clear_nooflegs() ;
  ::int32_t nooflegs() const;
  void set_nooflegs(::int32_t value);

  private:
  ::int32_t _internal_nooflegs() const;
  void _internal_set_nooflegs(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:com.cps2004.Table)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      31, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr shape_;
    ::com::cps2004::Furniture* furniture_;
    bool extendable_;
    ::int32_t nooflegs_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_5fstructures_2eproto;
};// -------------------------------------------------------------------

class Textbook final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.cps2004.Textbook) */ {
 public:
  inline Textbook() : Textbook(nullptr) {}
  ~Textbook() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Textbook(::google::protobuf::internal::ConstantInitialized);

  inline Textbook(const Textbook& from)
      : Textbook(nullptr, from) {}
  Textbook(Textbook&& from) noexcept
    : Textbook() {
    *this = ::std::move(from);
  }

  inline Textbook& operator=(const Textbook& from) {
    CopyFrom(from);
    return *this;
  }
  inline Textbook& operator=(Textbook&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Textbook& default_instance() {
    return *internal_default_instance();
  }
  static inline const Textbook* internal_default_instance() {
    return reinterpret_cast<const Textbook*>(
               &_Textbook_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Textbook& a, Textbook& b) {
    a.Swap(&b);
  }
  inline void Swap(Textbook* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Textbook* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Textbook* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Textbook>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Textbook& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Textbook& from) {
    Textbook::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Textbook* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.cps2004.Textbook";
  }
  protected:
  explicit Textbook(::google::protobuf::Arena* arena);
  Textbook(::google::protobuf::Arena* arena, const Textbook& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubjectFieldNumber = 2,
    kBookFieldNumber = 1,
    kEditionFieldNumber = 3,
  };
  // string subject = 2;
  void clear_subject() ;
  const std::string& subject() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subject(Arg_&& arg, Args_... args);
  std::string* mutable_subject();
  PROTOBUF_NODISCARD std::string* release_subject();
  void set_allocated_subject(std::string* value);

  private:
  const std::string& _internal_subject() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subject(
      const std::string& value);
  std::string* _internal_mutable_subject();

  public:
  // .com.cps2004.Book book = 1;
  bool has_book() const;
  void clear_book() ;
  const ::com::cps2004::Book& book() const;
  PROTOBUF_NODISCARD ::com::cps2004::Book* release_book();
  ::com::cps2004::Book* mutable_book();
  void set_allocated_book(::com::cps2004::Book* value);
  void unsafe_arena_set_allocated_book(::com::cps2004::Book* value);
  ::com::cps2004::Book* unsafe_arena_release_book();

  private:
  const ::com::cps2004::Book& _internal_book() const;
  ::com::cps2004::Book* _internal_mutable_book();

  public:
  // int32 edition = 3;
  void clear_edition() ;
  ::int32_t edition() const;
  void set_edition(::int32_t value);

  private:
  ::int32_t _internal_edition() const;
  void _internal_set_edition(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:com.cps2004.Textbook)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      36, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr subject_;
    ::com::cps2004::Book* book_;
    ::int32_t edition_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_5fstructures_2eproto;
};// -------------------------------------------------------------------

class VideoGame final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.cps2004.VideoGame) */ {
 public:
  inline VideoGame() : VideoGame(nullptr) {}
  ~VideoGame() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VideoGame(::google::protobuf::internal::ConstantInitialized);

  inline VideoGame(const VideoGame& from)
      : VideoGame(nullptr, from) {}
  VideoGame(VideoGame&& from) noexcept
    : VideoGame() {
    *this = ::std::move(from);
  }

  inline VideoGame& operator=(const VideoGame& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoGame& operator=(VideoGame&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VideoGame& default_instance() {
    return *internal_default_instance();
  }
  enum VideoGameTypeCase {
    kAction = 1,
    kRpg = 2,
    VIDEOGAME_TYPE_NOT_SET = 0,
  };

  static inline const VideoGame* internal_default_instance() {
    return reinterpret_cast<const VideoGame*>(
               &_VideoGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(VideoGame& a, VideoGame& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoGame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoGame* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VideoGame* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VideoGame>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VideoGame& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const VideoGame& from) {
    VideoGame::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(VideoGame* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.cps2004.VideoGame";
  }
  protected:
  explicit VideoGame(::google::protobuf::Arena* arena);
  VideoGame(::google::protobuf::Arena* arena, const VideoGame& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlatformFieldNumber = 4,
    kDeveloperFieldNumber = 5,
    kProductFieldNumber = 3,
    kActionFieldNumber = 1,
    kRpgFieldNumber = 2,
  };
  // string platform = 4;
  void clear_platform() ;
  const std::string& platform() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_platform(Arg_&& arg, Args_... args);
  std::string* mutable_platform();
  PROTOBUF_NODISCARD std::string* release_platform();
  void set_allocated_platform(std::string* value);

  private:
  const std::string& _internal_platform() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_platform(
      const std::string& value);
  std::string* _internal_mutable_platform();

  public:
  // string developer = 5;
  void clear_developer() ;
  const std::string& developer() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_developer(Arg_&& arg, Args_... args);
  std::string* mutable_developer();
  PROTOBUF_NODISCARD std::string* release_developer();
  void set_allocated_developer(std::string* value);

  private:
  const std::string& _internal_developer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_developer(
      const std::string& value);
  std::string* _internal_mutable_developer();

  public:
  // .com.cps2004.Product product = 3;
  bool has_product() const;
  void clear_product() ;
  const ::com::cps2004::Product& product() const;
  PROTOBUF_NODISCARD ::com::cps2004::Product* release_product();
  ::com::cps2004::Product* mutable_product();
  void set_allocated_product(::com::cps2004::Product* value);
  void unsafe_arena_set_allocated_product(::com::cps2004::Product* value);
  ::com::cps2004::Product* unsafe_arena_release_product();

  private:
  const ::com::cps2004::Product& _internal_product() const;
  ::com::cps2004::Product* _internal_mutable_product();

  public:
  // .com.cps2004.Action action = 1;
  bool has_action() const;
  private:
  bool _internal_has_action() const;

  public:
  void clear_action() ;
  const ::com::cps2004::Action& action() const;
  PROTOBUF_NODISCARD ::com::cps2004::Action* release_action();
  ::com::cps2004::Action* mutable_action();
  void set_allocated_action(::com::cps2004::Action* value);
  void unsafe_arena_set_allocated_action(::com::cps2004::Action* value);
  ::com::cps2004::Action* unsafe_arena_release_action();

  private:
  const ::com::cps2004::Action& _internal_action() const;
  ::com::cps2004::Action* _internal_mutable_action();

  public:
  // .com.cps2004.RPG rpg = 2;
  bool has_rpg() const;
  private:
  bool _internal_has_rpg() const;

  public:
  void clear_rpg() ;
  const ::com::cps2004::RPG& rpg() const;
  PROTOBUF_NODISCARD ::com::cps2004::RPG* release_rpg();
  ::com::cps2004::RPG* mutable_rpg();
  void set_allocated_rpg(::com::cps2004::RPG* value);
  void unsafe_arena_set_allocated_rpg(::com::cps2004::RPG* value);
  ::com::cps2004::RPG* unsafe_arena_release_rpg();

  private:
  const ::com::cps2004::RPG& _internal_rpg() const;
  ::com::cps2004::RPG* _internal_mutable_rpg();

  public:
  void clear_videoGame_type();
  VideoGameTypeCase videoGame_type_case() const;
  // @@protoc_insertion_point(class_scope:com.cps2004.VideoGame)
 private:
  class _Internal;
  void set_has_action();
  void set_has_rpg();

  inline bool has_videoGame_type() const;
  inline void clear_has_videoGame_type();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 5, 3,
      47, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr platform_;
    ::google::protobuf::internal::ArenaStringPtr developer_;
    ::com::cps2004::Product* product_;
    union VideoGameTypeUnion {
      constexpr VideoGameTypeUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::com::cps2004::Action* action_;
      ::com::cps2004::RPG* rpg_;
    } videoGame_type_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_5fstructures_2eproto;
};// -------------------------------------------------------------------

class StockItem final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.cps2004.StockItem) */ {
 public:
  inline StockItem() : StockItem(nullptr) {}
  ~StockItem() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StockItem(::google::protobuf::internal::ConstantInitialized);

  inline StockItem(const StockItem& from)
      : StockItem(nullptr, from) {}
  StockItem(StockItem&& from) noexcept
    : StockItem() {
    *this = ::std::move(from);
  }

  inline StockItem& operator=(const StockItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline StockItem& operator=(StockItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StockItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const StockItem* internal_default_instance() {
    return reinterpret_cast<const StockItem*>(
               &_StockItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(StockItem& a, StockItem& b) {
    a.Swap(&b);
  }
  inline void Swap(StockItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StockItem* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StockItem* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StockItem>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StockItem& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const StockItem& from) {
    StockItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StockItem* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.cps2004.StockItem";
  }
  protected:
  explicit StockItem(::google::protobuf::Arena* arena);
  StockItem(::google::protobuf::Arena* arena, const StockItem& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProductFieldNumber = 1,
    kQuantityFieldNumber = 2,
  };
  // .com.cps2004.Product product = 1;
  bool has_product() const;
  void clear_product() ;
  const ::com::cps2004::Product& product() const;
  PROTOBUF_NODISCARD ::com::cps2004::Product* release_product();
  ::com::cps2004::Product* mutable_product();
  void set_allocated_product(::com::cps2004::Product* value);
  void unsafe_arena_set_allocated_product(::com::cps2004::Product* value);
  ::com::cps2004::Product* unsafe_arena_release_product();

  private:
  const ::com::cps2004::Product& _internal_product() const;
  ::com::cps2004::Product* _internal_mutable_product();

  public:
  // int32 quantity = 2;
  void clear_quantity() ;
  ::int32_t quantity() const;
  void set_quantity(::int32_t value);

  private:
  ::int32_t _internal_quantity() const;
  void _internal_set_quantity(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:com.cps2004.StockItem)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::com::cps2004::Product* product_;
    ::int32_t quantity_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_5fstructures_2eproto;
};// -------------------------------------------------------------------

class ShipmentItem final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.cps2004.ShipmentItem) */ {
 public:
  inline ShipmentItem() : ShipmentItem(nullptr) {}
  ~ShipmentItem() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ShipmentItem(::google::protobuf::internal::ConstantInitialized);

  inline ShipmentItem(const ShipmentItem& from)
      : ShipmentItem(nullptr, from) {}
  ShipmentItem(ShipmentItem&& from) noexcept
    : ShipmentItem() {
    *this = ::std::move(from);
  }

  inline ShipmentItem& operator=(const ShipmentItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShipmentItem& operator=(ShipmentItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShipmentItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShipmentItem* internal_default_instance() {
    return reinterpret_cast<const ShipmentItem*>(
               &_ShipmentItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(ShipmentItem& a, ShipmentItem& b) {
    a.Swap(&b);
  }
  inline void Swap(ShipmentItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShipmentItem* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShipmentItem* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShipmentItem>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ShipmentItem& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ShipmentItem& from) {
    ShipmentItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ShipmentItem* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.cps2004.ShipmentItem";
  }
  protected:
  explicit ShipmentItem(::google::protobuf::Arena* arena);
  ShipmentItem(::google::protobuf::Arena* arena, const ShipmentItem& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProductFieldNumber = 3,
    kPackageFieldNumber = 4,
    kIdFieldNumber = 1,
    kQuantityFieldNumber = 2,
  };
  // .com.cps2004.Product product = 3;
  bool has_product() const;
  void clear_product() ;
  const ::com::cps2004::Product& product() const;
  PROTOBUF_NODISCARD ::com::cps2004::Product* release_product();
  ::com::cps2004::Product* mutable_product();
  void set_allocated_product(::com::cps2004::Product* value);
  void unsafe_arena_set_allocated_product(::com::cps2004::Product* value);
  ::com::cps2004::Product* unsafe_arena_release_product();

  private:
  const ::com::cps2004::Product& _internal_product() const;
  ::com::cps2004::Product* _internal_mutable_product();

  public:
  // .com.cps2004.Package package = 4;
  bool has_package() const;
  void clear_package() ;
  const ::com::cps2004::Package& package() const;
  PROTOBUF_NODISCARD ::com::cps2004::Package* release_package();
  ::com::cps2004::Package* mutable_package();
  void set_allocated_package(::com::cps2004::Package* value);
  void unsafe_arena_set_allocated_package(::com::cps2004::Package* value);
  ::com::cps2004::Package* unsafe_arena_release_package();

  private:
  const ::com::cps2004::Package& _internal_package() const;
  ::com::cps2004::Package* _internal_mutable_package();

  public:
  // int32 id = 1;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // int32 quantity = 2;
  void clear_quantity() ;
  ::int32_t quantity() const;
  void set_quantity(::int32_t value);

  private:
  ::int32_t _internal_quantity() const;
  void _internal_set_quantity(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:com.cps2004.ShipmentItem)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::com::cps2004::Product* product_;
    ::com::cps2004::Package* package_;
    ::int32_t id_;
    ::int32_t quantity_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_5fstructures_2eproto;
};// -------------------------------------------------------------------

class Stock final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.cps2004.Stock) */ {
 public:
  inline Stock() : Stock(nullptr) {}
  ~Stock() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Stock(::google::protobuf::internal::ConstantInitialized);

  inline Stock(const Stock& from)
      : Stock(nullptr, from) {}
  Stock(Stock&& from) noexcept
    : Stock() {
    *this = ::std::move(from);
  }

  inline Stock& operator=(const Stock& from) {
    CopyFrom(from);
    return *this;
  }
  inline Stock& operator=(Stock&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Stock& default_instance() {
    return *internal_default_instance();
  }
  static inline const Stock* internal_default_instance() {
    return reinterpret_cast<const Stock*>(
               &_Stock_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(Stock& a, Stock& b) {
    a.Swap(&b);
  }
  inline void Swap(Stock* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Stock* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Stock* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Stock>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Stock& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Stock& from) {
    Stock::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Stock* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.cps2004.Stock";
  }
  protected:
  explicit Stock(::google::protobuf::Arena* arena);
  Stock(::google::protobuf::Arena* arena, const Stock& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurrentstockFieldNumber = 1,
  };
  // repeated .com.cps2004.StockItem currentstock = 1;
  int currentstock_size() const;
  private:
  int _internal_currentstock_size() const;

  public:
  void clear_currentstock() ;
  ::com::cps2004::StockItem* mutable_currentstock(int index);
  ::google::protobuf::RepeatedPtrField< ::com::cps2004::StockItem >*
      mutable_currentstock();
  private:
  const ::google::protobuf::RepeatedPtrField<::com::cps2004::StockItem>& _internal_currentstock() const;
  ::google::protobuf::RepeatedPtrField<::com::cps2004::StockItem>* _internal_mutable_currentstock();
  public:
  const ::com::cps2004::StockItem& currentstock(int index) const;
  ::com::cps2004::StockItem* add_currentstock();
  const ::google::protobuf::RepeatedPtrField< ::com::cps2004::StockItem >&
      currentstock() const;
  // @@protoc_insertion_point(class_scope:com.cps2004.Stock)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::com::cps2004::StockItem > currentstock_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_5fstructures_2eproto;
};// -------------------------------------------------------------------

class Shipment final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.cps2004.Shipment) */ {
 public:
  inline Shipment() : Shipment(nullptr) {}
  ~Shipment() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Shipment(::google::protobuf::internal::ConstantInitialized);

  inline Shipment(const Shipment& from)
      : Shipment(nullptr, from) {}
  Shipment(Shipment&& from) noexcept
    : Shipment() {
    *this = ::std::move(from);
  }

  inline Shipment& operator=(const Shipment& from) {
    CopyFrom(from);
    return *this;
  }
  inline Shipment& operator=(Shipment&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Shipment& default_instance() {
    return *internal_default_instance();
  }
  static inline const Shipment* internal_default_instance() {
    return reinterpret_cast<const Shipment*>(
               &_Shipment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(Shipment& a, Shipment& b) {
    a.Swap(&b);
  }
  inline void Swap(Shipment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Shipment* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Shipment* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Shipment>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Shipment& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Shipment& from) {
    Shipment::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Shipment* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.cps2004.Shipment";
  }
  protected:
  explicit Shipment(::google::protobuf::Arena* arena);
  Shipment(::google::protobuf::Arena* arena, const Shipment& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPackagedItemsFieldNumber = 2,
    kDispatchedDateFieldNumber = 5,
    kTransportFieldNumber = 1,
    kDistanceFieldNumber = 4,
    kDispatchedFieldNumber = 3,
    kShipmentIDFieldNumber = 6,
  };
  // repeated .com.cps2004.ShipmentItem packagedItems = 2;
  int packageditems_size() const;
  private:
  int _internal_packageditems_size() const;

  public:
  void clear_packageditems() ;
  ::com::cps2004::ShipmentItem* mutable_packageditems(int index);
  ::google::protobuf::RepeatedPtrField< ::com::cps2004::ShipmentItem >*
      mutable_packageditems();
  private:
  const ::google::protobuf::RepeatedPtrField<::com::cps2004::ShipmentItem>& _internal_packageditems() const;
  ::google::protobuf::RepeatedPtrField<::com::cps2004::ShipmentItem>* _internal_mutable_packageditems();
  public:
  const ::com::cps2004::ShipmentItem& packageditems(int index) const;
  ::com::cps2004::ShipmentItem* add_packageditems();
  const ::google::protobuf::RepeatedPtrField< ::com::cps2004::ShipmentItem >&
      packageditems() const;
  // string dispatchedDate = 5;
  void clear_dispatcheddate() ;
  const std::string& dispatcheddate() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dispatcheddate(Arg_&& arg, Args_... args);
  std::string* mutable_dispatcheddate();
  PROTOBUF_NODISCARD std::string* release_dispatcheddate();
  void set_allocated_dispatcheddate(std::string* value);

  private:
  const std::string& _internal_dispatcheddate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dispatcheddate(
      const std::string& value);
  std::string* _internal_mutable_dispatcheddate();

  public:
  // .com.cps2004.Transport transport = 1;
  bool has_transport() const;
  void clear_transport() ;
  const ::com::cps2004::Transport& transport() const;
  PROTOBUF_NODISCARD ::com::cps2004::Transport* release_transport();
  ::com::cps2004::Transport* mutable_transport();
  void set_allocated_transport(::com::cps2004::Transport* value);
  void unsafe_arena_set_allocated_transport(::com::cps2004::Transport* value);
  ::com::cps2004::Transport* unsafe_arena_release_transport();

  private:
  const ::com::cps2004::Transport& _internal_transport() const;
  ::com::cps2004::Transport* _internal_mutable_transport();

  public:
  // double distance = 4;
  void clear_distance() ;
  double distance() const;
  void set_distance(double value);

  private:
  double _internal_distance() const;
  void _internal_set_distance(double value);

  public:
  // bool dispatched = 3;
  void clear_dispatched() ;
  bool dispatched() const;
  void set_dispatched(bool value);

  private:
  bool _internal_dispatched() const;
  void _internal_set_dispatched(bool value);

  public:
  // int32 shipmentID = 6;
  void clear_shipmentid() ;
  ::int32_t shipmentid() const;
  void set_shipmentid(::int32_t value);

  private:
  ::int32_t _internal_shipmentid() const;
  void _internal_set_shipmentid(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:com.cps2004.Shipment)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 2,
      43, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::com::cps2004::ShipmentItem > packageditems_;
    ::google::protobuf::internal::ArenaStringPtr dispatcheddate_;
    ::com::cps2004::Transport* transport_;
    double distance_;
    bool dispatched_;
    ::int32_t shipmentid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_5fstructures_2eproto;
};// -------------------------------------------------------------------

class Customer final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.cps2004.Customer) */ {
 public:
  inline Customer() : Customer(nullptr) {}
  ~Customer() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Customer(::google::protobuf::internal::ConstantInitialized);

  inline Customer(const Customer& from)
      : Customer(nullptr, from) {}
  Customer(Customer&& from) noexcept
    : Customer() {
    *this = ::std::move(from);
  }

  inline Customer& operator=(const Customer& from) {
    CopyFrom(from);
    return *this;
  }
  inline Customer& operator=(Customer&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Customer& default_instance() {
    return *internal_default_instance();
  }
  static inline const Customer* internal_default_instance() {
    return reinterpret_cast<const Customer*>(
               &_Customer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(Customer& a, Customer& b) {
    a.Swap(&b);
  }
  inline void Swap(Customer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Customer* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Customer* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Customer>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Customer& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Customer& from) {
    Customer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Customer* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.cps2004.Customer";
  }
  protected:
  explicit Customer(::google::protobuf::Arena* arena);
  Customer(::google::protobuf::Arena* arena, const Customer& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShipmentsFieldNumber = 5,
    kNameFieldNumber = 1,
    kAddressFieldNumber = 2,
    kDistanceFromWarehouseFieldNumber = 4,
    kIDFieldNumber = 3,
  };
  // repeated .com.cps2004.Shipment shipments = 5;
  int shipments_size() const;
  private:
  int _internal_shipments_size() const;

  public:
  void clear_shipments() ;
  ::com::cps2004::Shipment* mutable_shipments(int index);
  ::google::protobuf::RepeatedPtrField< ::com::cps2004::Shipment >*
      mutable_shipments();
  private:
  const ::google::protobuf::RepeatedPtrField<::com::cps2004::Shipment>& _internal_shipments() const;
  ::google::protobuf::RepeatedPtrField<::com::cps2004::Shipment>* _internal_mutable_shipments();
  public:
  const ::com::cps2004::Shipment& shipments(int index) const;
  ::com::cps2004::Shipment* add_shipments();
  const ::google::protobuf::RepeatedPtrField< ::com::cps2004::Shipment >&
      shipments() const;
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string address = 2;
  void clear_address() ;
  const std::string& address() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_address(Arg_&& arg, Args_... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* value);

  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(
      const std::string& value);
  std::string* _internal_mutable_address();

  public:
  // double distanceFromWarehouse = 4;
  void clear_distancefromwarehouse() ;
  double distancefromwarehouse() const;
  void set_distancefromwarehouse(double value);

  private:
  double _internal_distancefromwarehouse() const;
  void _internal_set_distancefromwarehouse(double value);

  public:
  // int32 ID = 3;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:com.cps2004.Customer)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      40, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::com::cps2004::Shipment > shipments_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr address_;
    double distancefromwarehouse_;
    ::int32_t id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_5fstructures_2eproto;
};// -------------------------------------------------------------------

class State final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.cps2004.State) */ {
 public:
  inline State() : State(nullptr) {}
  ~State() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR State(::google::protobuf::internal::ConstantInitialized);

  inline State(const State& from)
      : State(nullptr, from) {}
  State(State&& from) noexcept
    : State() {
    *this = ::std::move(from);
  }

  inline State& operator=(const State& from) {
    CopyFrom(from);
    return *this;
  }
  inline State& operator=(State&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const State& default_instance() {
    return *internal_default_instance();
  }
  static inline const State* internal_default_instance() {
    return reinterpret_cast<const State*>(
               &_State_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(State& a, State& b) {
    a.Swap(&b);
  }
  inline void Swap(State* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(State* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  State* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<State>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const State& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const State& from) {
    State::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(State* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "com.cps2004.State";
  }
  protected:
  explicit State(::google::protobuf::Arena* arena);
  State(::google::protobuf::Arena* arena, const State& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransportsFieldNumber = 1,
    kSuppliersFieldNumber = 2,
    kCustomersFieldNumber = 3,
    kPackagesFieldNumber = 4,
    kStockFieldNumber = 5,
  };
  // repeated .com.cps2004.Transport transports = 1;
  int transports_size() const;
  private:
  int _internal_transports_size() const;

  public:
  void clear_transports() ;
  ::com::cps2004::Transport* mutable_transports(int index);
  ::google::protobuf::RepeatedPtrField< ::com::cps2004::Transport >*
      mutable_transports();
  private:
  const ::google::protobuf::RepeatedPtrField<::com::cps2004::Transport>& _internal_transports() const;
  ::google::protobuf::RepeatedPtrField<::com::cps2004::Transport>* _internal_mutable_transports();
  public:
  const ::com::cps2004::Transport& transports(int index) const;
  ::com::cps2004::Transport* add_transports();
  const ::google::protobuf::RepeatedPtrField< ::com::cps2004::Transport >&
      transports() const;
  // repeated .com.cps2004.Supplier suppliers = 2;
  int suppliers_size() const;
  private:
  int _internal_suppliers_size() const;

  public:
  void clear_suppliers() ;
  ::com::cps2004::Supplier* mutable_suppliers(int index);
  ::google::protobuf::RepeatedPtrField< ::com::cps2004::Supplier >*
      mutable_suppliers();
  private:
  const ::google::protobuf::RepeatedPtrField<::com::cps2004::Supplier>& _internal_suppliers() const;
  ::google::protobuf::RepeatedPtrField<::com::cps2004::Supplier>* _internal_mutable_suppliers();
  public:
  const ::com::cps2004::Supplier& suppliers(int index) const;
  ::com::cps2004::Supplier* add_suppliers();
  const ::google::protobuf::RepeatedPtrField< ::com::cps2004::Supplier >&
      suppliers() const;
  // repeated .com.cps2004.Customer customers = 3;
  int customers_size() const;
  private:
  int _internal_customers_size() const;

  public:
  void clear_customers() ;
  ::com::cps2004::Customer* mutable_customers(int index);
  ::google::protobuf::RepeatedPtrField< ::com::cps2004::Customer >*
      mutable_customers();
  private:
  const ::google::protobuf::RepeatedPtrField<::com::cps2004::Customer>& _internal_customers() const;
  ::google::protobuf::RepeatedPtrField<::com::cps2004::Customer>* _internal_mutable_customers();
  public:
  const ::com::cps2004::Customer& customers(int index) const;
  ::com::cps2004::Customer* add_customers();
  const ::google::protobuf::RepeatedPtrField< ::com::cps2004::Customer >&
      customers() const;
  // repeated .com.cps2004.Package packages = 4;
  int packages_size() const;
  private:
  int _internal_packages_size() const;

  public:
  void clear_packages() ;
  ::com::cps2004::Package* mutable_packages(int index);
  ::google::protobuf::RepeatedPtrField< ::com::cps2004::Package >*
      mutable_packages();
  private:
  const ::google::protobuf::RepeatedPtrField<::com::cps2004::Package>& _internal_packages() const;
  ::google::protobuf::RepeatedPtrField<::com::cps2004::Package>* _internal_mutable_packages();
  public:
  const ::com::cps2004::Package& packages(int index) const;
  ::com::cps2004::Package* add_packages();
  const ::google::protobuf::RepeatedPtrField< ::com::cps2004::Package >&
      packages() const;
  // .com.cps2004.Stock stock = 5;
  bool has_stock() const;
  void clear_stock() ;
  const ::com::cps2004::Stock& stock() const;
  PROTOBUF_NODISCARD ::com::cps2004::Stock* release_stock();
  ::com::cps2004::Stock* mutable_stock();
  void set_allocated_stock(::com::cps2004::Stock* value);
  void unsafe_arena_set_allocated_stock(::com::cps2004::Stock* value);
  ::com::cps2004::Stock* unsafe_arena_release_stock();

  private:
  const ::com::cps2004::Stock& _internal_stock() const;
  ::com::cps2004::Stock* _internal_mutable_stock();

  public:
  // @@protoc_insertion_point(class_scope:com.cps2004.State)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 5,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::com::cps2004::Transport > transports_;
    ::google::protobuf::RepeatedPtrField< ::com::cps2004::Supplier > suppliers_;
    ::google::protobuf::RepeatedPtrField< ::com::cps2004::Customer > customers_;
    ::google::protobuf::RepeatedPtrField< ::com::cps2004::Package > packages_;
    ::com::cps2004::Stock* stock_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_5fstructures_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Transport

// .com.cps2004.Ship ship = 1;
inline bool Transport::has_ship() const {
  return transport_type_case() == kShip;
}
inline bool Transport::_internal_has_ship() const {
  return transport_type_case() == kShip;
}
inline void Transport::set_has_ship() {
  _impl_._oneof_case_[0] = kShip;
}
inline void Transport::clear_ship() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (transport_type_case() == kShip) {
    if (GetArena() == nullptr) {
      delete _impl_.transport_type_.ship_;
    }
    clear_has_transport_type();
  }
}
inline ::com::cps2004::Ship* Transport::release_ship() {
  // @@protoc_insertion_point(field_release:com.cps2004.Transport.ship)
  if (transport_type_case() == kShip) {
    clear_has_transport_type();
    auto* temp = _impl_.transport_type_.ship_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.transport_type_.ship_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::com::cps2004::Ship& Transport::_internal_ship() const {
  return transport_type_case() == kShip ? *_impl_.transport_type_.ship_ : reinterpret_cast<::com::cps2004::Ship&>(::com::cps2004::_Ship_default_instance_);
}
inline const ::com::cps2004::Ship& Transport::ship() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Transport.ship)
  return _internal_ship();
}
inline ::com::cps2004::Ship* Transport::unsafe_arena_release_ship() {
  // @@protoc_insertion_point(field_unsafe_arena_release:com.cps2004.Transport.ship)
  if (transport_type_case() == kShip) {
    clear_has_transport_type();
    auto* temp = _impl_.transport_type_.ship_;
    _impl_.transport_type_.ship_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Transport::unsafe_arena_set_allocated_ship(::com::cps2004::Ship* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_transport_type();
  if (value) {
    set_has_ship();
    _impl_.transport_type_.ship_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.cps2004.Transport.ship)
}
inline ::com::cps2004::Ship* Transport::_internal_mutable_ship() {
  if (transport_type_case() != kShip) {
    clear_transport_type();
    set_has_ship();
    _impl_.transport_type_.ship_ = CreateMaybeMessage<::com::cps2004::Ship>(GetArena());
  }
  return _impl_.transport_type_.ship_;
}
inline ::com::cps2004::Ship* Transport::mutable_ship() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::cps2004::Ship* _msg = _internal_mutable_ship();
  // @@protoc_insertion_point(field_mutable:com.cps2004.Transport.ship)
  return _msg;
}

// .com.cps2004.Plane plane = 2;
inline bool Transport::has_plane() const {
  return transport_type_case() == kPlane;
}
inline bool Transport::_internal_has_plane() const {
  return transport_type_case() == kPlane;
}
inline void Transport::set_has_plane() {
  _impl_._oneof_case_[0] = kPlane;
}
inline void Transport::clear_plane() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (transport_type_case() == kPlane) {
    if (GetArena() == nullptr) {
      delete _impl_.transport_type_.plane_;
    }
    clear_has_transport_type();
  }
}
inline ::com::cps2004::Plane* Transport::release_plane() {
  // @@protoc_insertion_point(field_release:com.cps2004.Transport.plane)
  if (transport_type_case() == kPlane) {
    clear_has_transport_type();
    auto* temp = _impl_.transport_type_.plane_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.transport_type_.plane_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::com::cps2004::Plane& Transport::_internal_plane() const {
  return transport_type_case() == kPlane ? *_impl_.transport_type_.plane_ : reinterpret_cast<::com::cps2004::Plane&>(::com::cps2004::_Plane_default_instance_);
}
inline const ::com::cps2004::Plane& Transport::plane() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Transport.plane)
  return _internal_plane();
}
inline ::com::cps2004::Plane* Transport::unsafe_arena_release_plane() {
  // @@protoc_insertion_point(field_unsafe_arena_release:com.cps2004.Transport.plane)
  if (transport_type_case() == kPlane) {
    clear_has_transport_type();
    auto* temp = _impl_.transport_type_.plane_;
    _impl_.transport_type_.plane_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Transport::unsafe_arena_set_allocated_plane(::com::cps2004::Plane* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_transport_type();
  if (value) {
    set_has_plane();
    _impl_.transport_type_.plane_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.cps2004.Transport.plane)
}
inline ::com::cps2004::Plane* Transport::_internal_mutable_plane() {
  if (transport_type_case() != kPlane) {
    clear_transport_type();
    set_has_plane();
    _impl_.transport_type_.plane_ = CreateMaybeMessage<::com::cps2004::Plane>(GetArena());
  }
  return _impl_.transport_type_.plane_;
}
inline ::com::cps2004::Plane* Transport::mutable_plane() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::cps2004::Plane* _msg = _internal_mutable_plane();
  // @@protoc_insertion_point(field_mutable:com.cps2004.Transport.plane)
  return _msg;
}

// .com.cps2004.Truck truck = 3;
inline bool Transport::has_truck() const {
  return transport_type_case() == kTruck;
}
inline bool Transport::_internal_has_truck() const {
  return transport_type_case() == kTruck;
}
inline void Transport::set_has_truck() {
  _impl_._oneof_case_[0] = kTruck;
}
inline void Transport::clear_truck() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (transport_type_case() == kTruck) {
    if (GetArena() == nullptr) {
      delete _impl_.transport_type_.truck_;
    }
    clear_has_transport_type();
  }
}
inline ::com::cps2004::Truck* Transport::release_truck() {
  // @@protoc_insertion_point(field_release:com.cps2004.Transport.truck)
  if (transport_type_case() == kTruck) {
    clear_has_transport_type();
    auto* temp = _impl_.transport_type_.truck_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.transport_type_.truck_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::com::cps2004::Truck& Transport::_internal_truck() const {
  return transport_type_case() == kTruck ? *_impl_.transport_type_.truck_ : reinterpret_cast<::com::cps2004::Truck&>(::com::cps2004::_Truck_default_instance_);
}
inline const ::com::cps2004::Truck& Transport::truck() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Transport.truck)
  return _internal_truck();
}
inline ::com::cps2004::Truck* Transport::unsafe_arena_release_truck() {
  // @@protoc_insertion_point(field_unsafe_arena_release:com.cps2004.Transport.truck)
  if (transport_type_case() == kTruck) {
    clear_has_transport_type();
    auto* temp = _impl_.transport_type_.truck_;
    _impl_.transport_type_.truck_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Transport::unsafe_arena_set_allocated_truck(::com::cps2004::Truck* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_transport_type();
  if (value) {
    set_has_truck();
    _impl_.transport_type_.truck_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.cps2004.Transport.truck)
}
inline ::com::cps2004::Truck* Transport::_internal_mutable_truck() {
  if (transport_type_case() != kTruck) {
    clear_transport_type();
    set_has_truck();
    _impl_.transport_type_.truck_ = CreateMaybeMessage<::com::cps2004::Truck>(GetArena());
  }
  return _impl_.transport_type_.truck_;
}
inline ::com::cps2004::Truck* Transport::mutable_truck() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::cps2004::Truck* _msg = _internal_mutable_truck();
  // @@protoc_insertion_point(field_mutable:com.cps2004.Transport.truck)
  return _msg;
}

// int32 transportSpeed = 4;
inline void Transport::clear_transportspeed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.transportspeed_ = 0;
}
inline ::int32_t Transport::transportspeed() const {
  // @@protoc_insertion_point(field_get:com.cps2004.Transport.transportSpeed)
  return _internal_transportspeed();
}
inline void Transport::set_transportspeed(::int32_t value) {
  _internal_set_transportspeed(value);
  // @@protoc_insertion_point(field_set:com.cps2004.Transport.transportSpeed)
}
inline ::int32_t Transport::_internal_transportspeed() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.transportspeed_;
}
inline void Transport::_internal_set_transportspeed(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.transportspeed_ = value;
}

// int32 costPerKm = 5;
inline void Transport::clear_costperkm() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.costperkm_ = 0;
}
inline ::int32_t Transport::costperkm() const {
  // @@protoc_insertion_point(field_get:com.cps2004.Transport.costPerKm)
  return _internal_costperkm();
}
inline void Transport::set_costperkm(::int32_t value) {
  _internal_set_costperkm(value);
  // @@protoc_insertion_point(field_set:com.cps2004.Transport.costPerKm)
}
inline ::int32_t Transport::_internal_costperkm() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.costperkm_;
}
inline void Transport::_internal_set_costperkm(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.costperkm_ = value;
}

// int32 transportID = 6;
inline void Transport::clear_transportid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.transportid_ = 0;
}
inline ::int32_t Transport::transportid() const {
  // @@protoc_insertion_point(field_get:com.cps2004.Transport.transportID)
  return _internal_transportid();
}
inline void Transport::set_transportid(::int32_t value) {
  _internal_set_transportid(value);
  // @@protoc_insertion_point(field_set:com.cps2004.Transport.transportID)
}
inline ::int32_t Transport::_internal_transportid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.transportid_;
}
inline void Transport::_internal_set_transportid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.transportid_ = value;
}

inline bool Transport::has_transport_type() const {
  return transport_type_case() != TRANSPORT_TYPE_NOT_SET;
}
inline void Transport::clear_has_transport_type() {
  _impl_._oneof_case_[0] = TRANSPORT_TYPE_NOT_SET;
}
inline Transport::TransportTypeCase Transport::transport_type_case() const {
  return Transport::TransportTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Ship

// .com.cps2004.Transport transport = 1;
inline bool Ship::has_transport() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.transport_ != nullptr);
  return value;
}
inline void Ship::clear_transport() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.transport_ != nullptr) _impl_.transport_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::com::cps2004::Transport& Ship::_internal_transport() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::cps2004::Transport* p = _impl_.transport_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::cps2004::Transport&>(::com::cps2004::_Transport_default_instance_);
}
inline const ::com::cps2004::Transport& Ship::transport() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Ship.transport)
  return _internal_transport();
}
inline void Ship::unsafe_arena_set_allocated_transport(::com::cps2004::Transport* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.transport_);
  }
  _impl_.transport_ = reinterpret_cast<::com::cps2004::Transport*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.cps2004.Ship.transport)
}
inline ::com::cps2004::Transport* Ship::release_transport() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::cps2004::Transport* released = _impl_.transport_;
  _impl_.transport_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::cps2004::Transport* Ship::unsafe_arena_release_transport() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.cps2004.Ship.transport)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::cps2004::Transport* temp = _impl_.transport_;
  _impl_.transport_ = nullptr;
  return temp;
}
inline ::com::cps2004::Transport* Ship::_internal_mutable_transport() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.transport_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::cps2004::Transport>(GetArena());
    _impl_.transport_ = reinterpret_cast<::com::cps2004::Transport*>(p);
  }
  return _impl_.transport_;
}
inline ::com::cps2004::Transport* Ship::mutable_transport() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::cps2004::Transport* _msg = _internal_mutable_transport();
  // @@protoc_insertion_point(field_mutable:com.cps2004.Ship.transport)
  return _msg;
}
inline void Ship::set_allocated_transport(::com::cps2004::Transport* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::cps2004::Transport*>(_impl_.transport_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::cps2004::Transport*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.transport_ = reinterpret_cast<::com::cps2004::Transport*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.cps2004.Ship.transport)
}

// repeated string harbours = 2;
inline int Ship::_internal_harbours_size() const {
  return _internal_harbours().size();
}
inline int Ship::harbours_size() const {
  return _internal_harbours_size();
}
inline void Ship::clear_harbours() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.harbours_.Clear();
}
inline std::string* Ship::add_harbours()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_harbours()->Add();
  // @@protoc_insertion_point(field_add_mutable:com.cps2004.Ship.harbours)
  return _s;
}
inline const std::string& Ship::harbours(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Ship.harbours)
  return _internal_harbours().Get(index);
}
inline std::string* Ship::mutable_harbours(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:com.cps2004.Ship.harbours)
  return _internal_mutable_harbours()->Mutable(index);
}
inline void Ship::set_harbours(int index, const std::string& value) {
  _internal_mutable_harbours()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:com.cps2004.Ship.harbours)
}
inline void Ship::set_harbours(int index, std::string&& value) {
  _internal_mutable_harbours()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:com.cps2004.Ship.harbours)
}
inline void Ship::set_harbours(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_harbours()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:com.cps2004.Ship.harbours)
}
inline void Ship::set_harbours(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_harbours()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.cps2004.Ship.harbours)
}
inline void Ship::set_harbours(int index, absl::string_view value) {
  _internal_mutable_harbours()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:com.cps2004.Ship.harbours)
}
inline void Ship::add_harbours(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_harbours()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:com.cps2004.Ship.harbours)
}
inline void Ship::add_harbours(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_harbours()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:com.cps2004.Ship.harbours)
}
inline void Ship::add_harbours(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_harbours()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:com.cps2004.Ship.harbours)
}
inline void Ship::add_harbours(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_harbours()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:com.cps2004.Ship.harbours)
}
inline void Ship::add_harbours(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_harbours()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:com.cps2004.Ship.harbours)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Ship::harbours() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:com.cps2004.Ship.harbours)
  return _internal_harbours();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Ship::mutable_harbours() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:com.cps2004.Ship.harbours)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_harbours();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Ship::_internal_harbours() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.harbours_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Ship::_internal_mutable_harbours() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.harbours_;
}

// -------------------------------------------------------------------

// Plane

// .com.cps2004.Transport transport = 1;
inline bool Plane::has_transport() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.transport_ != nullptr);
  return value;
}
inline void Plane::clear_transport() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.transport_ != nullptr) _impl_.transport_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::com::cps2004::Transport& Plane::_internal_transport() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::cps2004::Transport* p = _impl_.transport_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::cps2004::Transport&>(::com::cps2004::_Transport_default_instance_);
}
inline const ::com::cps2004::Transport& Plane::transport() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Plane.transport)
  return _internal_transport();
}
inline void Plane::unsafe_arena_set_allocated_transport(::com::cps2004::Transport* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.transport_);
  }
  _impl_.transport_ = reinterpret_cast<::com::cps2004::Transport*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.cps2004.Plane.transport)
}
inline ::com::cps2004::Transport* Plane::release_transport() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::cps2004::Transport* released = _impl_.transport_;
  _impl_.transport_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::cps2004::Transport* Plane::unsafe_arena_release_transport() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.cps2004.Plane.transport)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::cps2004::Transport* temp = _impl_.transport_;
  _impl_.transport_ = nullptr;
  return temp;
}
inline ::com::cps2004::Transport* Plane::_internal_mutable_transport() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.transport_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::cps2004::Transport>(GetArena());
    _impl_.transport_ = reinterpret_cast<::com::cps2004::Transport*>(p);
  }
  return _impl_.transport_;
}
inline ::com::cps2004::Transport* Plane::mutable_transport() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::cps2004::Transport* _msg = _internal_mutable_transport();
  // @@protoc_insertion_point(field_mutable:com.cps2004.Plane.transport)
  return _msg;
}
inline void Plane::set_allocated_transport(::com::cps2004::Transport* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::cps2004::Transport*>(_impl_.transport_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::cps2004::Transport*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.transport_ = reinterpret_cast<::com::cps2004::Transport*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.cps2004.Plane.transport)
}

// repeated string airSpaces = 2;
inline int Plane::_internal_airspaces_size() const {
  return _internal_airspaces().size();
}
inline int Plane::airspaces_size() const {
  return _internal_airspaces_size();
}
inline void Plane::clear_airspaces() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.airspaces_.Clear();
}
inline std::string* Plane::add_airspaces()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_airspaces()->Add();
  // @@protoc_insertion_point(field_add_mutable:com.cps2004.Plane.airSpaces)
  return _s;
}
inline const std::string& Plane::airspaces(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Plane.airSpaces)
  return _internal_airspaces().Get(index);
}
inline std::string* Plane::mutable_airspaces(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:com.cps2004.Plane.airSpaces)
  return _internal_mutable_airspaces()->Mutable(index);
}
inline void Plane::set_airspaces(int index, const std::string& value) {
  _internal_mutable_airspaces()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:com.cps2004.Plane.airSpaces)
}
inline void Plane::set_airspaces(int index, std::string&& value) {
  _internal_mutable_airspaces()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:com.cps2004.Plane.airSpaces)
}
inline void Plane::set_airspaces(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_airspaces()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:com.cps2004.Plane.airSpaces)
}
inline void Plane::set_airspaces(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_airspaces()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.cps2004.Plane.airSpaces)
}
inline void Plane::set_airspaces(int index, absl::string_view value) {
  _internal_mutable_airspaces()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:com.cps2004.Plane.airSpaces)
}
inline void Plane::add_airspaces(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_airspaces()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:com.cps2004.Plane.airSpaces)
}
inline void Plane::add_airspaces(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_airspaces()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:com.cps2004.Plane.airSpaces)
}
inline void Plane::add_airspaces(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_airspaces()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:com.cps2004.Plane.airSpaces)
}
inline void Plane::add_airspaces(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_airspaces()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:com.cps2004.Plane.airSpaces)
}
inline void Plane::add_airspaces(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_airspaces()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:com.cps2004.Plane.airSpaces)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Plane::airspaces() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:com.cps2004.Plane.airSpaces)
  return _internal_airspaces();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Plane::mutable_airspaces() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:com.cps2004.Plane.airSpaces)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_airspaces();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Plane::_internal_airspaces() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.airspaces_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Plane::_internal_mutable_airspaces() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.airspaces_;
}

// -------------------------------------------------------------------

// Truck

// .com.cps2004.Transport transport = 1;
inline bool Truck::has_transport() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.transport_ != nullptr);
  return value;
}
inline void Truck::clear_transport() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.transport_ != nullptr) _impl_.transport_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::com::cps2004::Transport& Truck::_internal_transport() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::cps2004::Transport* p = _impl_.transport_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::cps2004::Transport&>(::com::cps2004::_Transport_default_instance_);
}
inline const ::com::cps2004::Transport& Truck::transport() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Truck.transport)
  return _internal_transport();
}
inline void Truck::unsafe_arena_set_allocated_transport(::com::cps2004::Transport* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.transport_);
  }
  _impl_.transport_ = reinterpret_cast<::com::cps2004::Transport*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.cps2004.Truck.transport)
}
inline ::com::cps2004::Transport* Truck::release_transport() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::cps2004::Transport* released = _impl_.transport_;
  _impl_.transport_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::cps2004::Transport* Truck::unsafe_arena_release_transport() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.cps2004.Truck.transport)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::cps2004::Transport* temp = _impl_.transport_;
  _impl_.transport_ = nullptr;
  return temp;
}
inline ::com::cps2004::Transport* Truck::_internal_mutable_transport() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.transport_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::cps2004::Transport>(GetArena());
    _impl_.transport_ = reinterpret_cast<::com::cps2004::Transport*>(p);
  }
  return _impl_.transport_;
}
inline ::com::cps2004::Transport* Truck::mutable_transport() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::cps2004::Transport* _msg = _internal_mutable_transport();
  // @@protoc_insertion_point(field_mutable:com.cps2004.Truck.transport)
  return _msg;
}
inline void Truck::set_allocated_transport(::com::cps2004::Transport* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::cps2004::Transport*>(_impl_.transport_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::cps2004::Transport*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.transport_ = reinterpret_cast<::com::cps2004::Transport*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.cps2004.Truck.transport)
}

// repeated string roads = 2;
inline int Truck::_internal_roads_size() const {
  return _internal_roads().size();
}
inline int Truck::roads_size() const {
  return _internal_roads_size();
}
inline void Truck::clear_roads() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.roads_.Clear();
}
inline std::string* Truck::add_roads()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_roads()->Add();
  // @@protoc_insertion_point(field_add_mutable:com.cps2004.Truck.roads)
  return _s;
}
inline const std::string& Truck::roads(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Truck.roads)
  return _internal_roads().Get(index);
}
inline std::string* Truck::mutable_roads(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:com.cps2004.Truck.roads)
  return _internal_mutable_roads()->Mutable(index);
}
inline void Truck::set_roads(int index, const std::string& value) {
  _internal_mutable_roads()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:com.cps2004.Truck.roads)
}
inline void Truck::set_roads(int index, std::string&& value) {
  _internal_mutable_roads()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:com.cps2004.Truck.roads)
}
inline void Truck::set_roads(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_roads()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:com.cps2004.Truck.roads)
}
inline void Truck::set_roads(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_roads()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.cps2004.Truck.roads)
}
inline void Truck::set_roads(int index, absl::string_view value) {
  _internal_mutable_roads()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:com.cps2004.Truck.roads)
}
inline void Truck::add_roads(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_roads()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:com.cps2004.Truck.roads)
}
inline void Truck::add_roads(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_roads()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:com.cps2004.Truck.roads)
}
inline void Truck::add_roads(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_roads()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:com.cps2004.Truck.roads)
}
inline void Truck::add_roads(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_roads()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:com.cps2004.Truck.roads)
}
inline void Truck::add_roads(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_roads()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:com.cps2004.Truck.roads)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Truck::roads() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:com.cps2004.Truck.roads)
  return _internal_roads();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Truck::mutable_roads() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:com.cps2004.Truck.roads)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_roads();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Truck::_internal_roads() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.roads_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Truck::_internal_mutable_roads() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.roads_;
}

// -------------------------------------------------------------------

// Supplier

// string name = 1;
inline void Supplier::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Supplier::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Supplier.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Supplier::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:com.cps2004.Supplier.name)
}
inline std::string* Supplier::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:com.cps2004.Supplier.name)
  return _s;
}
inline const std::string& Supplier::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void Supplier::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Supplier::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Supplier::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.cps2004.Supplier.name)
  return _impl_.name_.Release();
}
inline void Supplier::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.cps2004.Supplier.name)
}

// int32 supplierID = 2;
inline void Supplier::clear_supplierid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.supplierid_ = 0;
}
inline ::int32_t Supplier::supplierid() const {
  // @@protoc_insertion_point(field_get:com.cps2004.Supplier.supplierID)
  return _internal_supplierid();
}
inline void Supplier::set_supplierid(::int32_t value) {
  _internal_set_supplierid(value);
  // @@protoc_insertion_point(field_set:com.cps2004.Supplier.supplierID)
}
inline ::int32_t Supplier::_internal_supplierid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.supplierid_;
}
inline void Supplier::_internal_set_supplierid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.supplierid_ = value;
}

// -------------------------------------------------------------------

// Package

// int32 packagingUnits = 1;
inline void Package::clear_packagingunits() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.packagingunits_ = 0;
}
inline ::int32_t Package::packagingunits() const {
  // @@protoc_insertion_point(field_get:com.cps2004.Package.packagingUnits)
  return _internal_packagingunits();
}
inline void Package::set_packagingunits(::int32_t value) {
  _internal_set_packagingunits(value);
  // @@protoc_insertion_point(field_set:com.cps2004.Package.packagingUnits)
}
inline ::int32_t Package::_internal_packagingunits() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.packagingunits_;
}
inline void Package::_internal_set_packagingunits(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.packagingunits_ = value;
}

// double cost = 2;
inline void Package::clear_cost() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cost_ = 0;
}
inline double Package::cost() const {
  // @@protoc_insertion_point(field_get:com.cps2004.Package.cost)
  return _internal_cost();
}
inline void Package::set_cost(double value) {
  _internal_set_cost(value);
  // @@protoc_insertion_point(field_set:com.cps2004.Package.cost)
}
inline double Package::_internal_cost() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cost_;
}
inline void Package::_internal_set_cost(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.cost_ = value;
}

// string type = 3;
inline void Package::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_.ClearToEmpty();
}
inline const std::string& Package::type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Package.type)
  return _internal_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Package::set_type(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:com.cps2004.Package.type)
}
inline std::string* Package::mutable_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:com.cps2004.Package.type)
  return _s;
}
inline const std::string& Package::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.type_.Get();
}
inline void Package::_internal_set_type(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_.Set(value, GetArena());
}
inline std::string* Package::_internal_mutable_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.type_.Mutable( GetArena());
}
inline std::string* Package::release_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.cps2004.Package.type)
  return _impl_.type_.Release();
}
inline void Package::set_allocated_type(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.type_.IsDefault()) {
          _impl_.type_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.cps2004.Package.type)
}

// int32 packageID = 4;
inline void Package::clear_packageid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.packageid_ = 0;
}
inline ::int32_t Package::packageid() const {
  // @@protoc_insertion_point(field_get:com.cps2004.Package.packageID)
  return _internal_packageid();
}
inline void Package::set_packageid(::int32_t value) {
  _internal_set_packageid(value);
  // @@protoc_insertion_point(field_set:com.cps2004.Package.packageID)
}
inline ::int32_t Package::_internal_packageid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.packageid_;
}
inline void Package::_internal_set_packageid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.packageid_ = value;
}

// -------------------------------------------------------------------

// Product

// .com.cps2004.Book book = 1;
inline bool Product::has_book() const {
  return product_type_case() == kBook;
}
inline bool Product::_internal_has_book() const {
  return product_type_case() == kBook;
}
inline void Product::set_has_book() {
  _impl_._oneof_case_[0] = kBook;
}
inline void Product::clear_book() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (product_type_case() == kBook) {
    if (GetArena() == nullptr) {
      delete _impl_.product_type_.book_;
    }
    clear_has_product_type();
  }
}
inline ::com::cps2004::Book* Product::release_book() {
  // @@protoc_insertion_point(field_release:com.cps2004.Product.book)
  if (product_type_case() == kBook) {
    clear_has_product_type();
    auto* temp = _impl_.product_type_.book_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.product_type_.book_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::com::cps2004::Book& Product::_internal_book() const {
  return product_type_case() == kBook ? *_impl_.product_type_.book_ : reinterpret_cast<::com::cps2004::Book&>(::com::cps2004::_Book_default_instance_);
}
inline const ::com::cps2004::Book& Product::book() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Product.book)
  return _internal_book();
}
inline ::com::cps2004::Book* Product::unsafe_arena_release_book() {
  // @@protoc_insertion_point(field_unsafe_arena_release:com.cps2004.Product.book)
  if (product_type_case() == kBook) {
    clear_has_product_type();
    auto* temp = _impl_.product_type_.book_;
    _impl_.product_type_.book_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Product::unsafe_arena_set_allocated_book(::com::cps2004::Book* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_product_type();
  if (value) {
    set_has_book();
    _impl_.product_type_.book_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.cps2004.Product.book)
}
inline ::com::cps2004::Book* Product::_internal_mutable_book() {
  if (product_type_case() != kBook) {
    clear_product_type();
    set_has_book();
    _impl_.product_type_.book_ = CreateMaybeMessage<::com::cps2004::Book>(GetArena());
  }
  return _impl_.product_type_.book_;
}
inline ::com::cps2004::Book* Product::mutable_book() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::cps2004::Book* _msg = _internal_mutable_book();
  // @@protoc_insertion_point(field_mutable:com.cps2004.Product.book)
  return _msg;
}

// .com.cps2004.Electronics electronics = 2;
inline bool Product::has_electronics() const {
  return product_type_case() == kElectronics;
}
inline bool Product::_internal_has_electronics() const {
  return product_type_case() == kElectronics;
}
inline void Product::set_has_electronics() {
  _impl_._oneof_case_[0] = kElectronics;
}
inline void Product::clear_electronics() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (product_type_case() == kElectronics) {
    if (GetArena() == nullptr) {
      delete _impl_.product_type_.electronics_;
    }
    clear_has_product_type();
  }
}
inline ::com::cps2004::Electronics* Product::release_electronics() {
  // @@protoc_insertion_point(field_release:com.cps2004.Product.electronics)
  if (product_type_case() == kElectronics) {
    clear_has_product_type();
    auto* temp = _impl_.product_type_.electronics_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.product_type_.electronics_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::com::cps2004::Electronics& Product::_internal_electronics() const {
  return product_type_case() == kElectronics ? *_impl_.product_type_.electronics_ : reinterpret_cast<::com::cps2004::Electronics&>(::com::cps2004::_Electronics_default_instance_);
}
inline const ::com::cps2004::Electronics& Product::electronics() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Product.electronics)
  return _internal_electronics();
}
inline ::com::cps2004::Electronics* Product::unsafe_arena_release_electronics() {
  // @@protoc_insertion_point(field_unsafe_arena_release:com.cps2004.Product.electronics)
  if (product_type_case() == kElectronics) {
    clear_has_product_type();
    auto* temp = _impl_.product_type_.electronics_;
    _impl_.product_type_.electronics_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Product::unsafe_arena_set_allocated_electronics(::com::cps2004::Electronics* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_product_type();
  if (value) {
    set_has_electronics();
    _impl_.product_type_.electronics_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.cps2004.Product.electronics)
}
inline ::com::cps2004::Electronics* Product::_internal_mutable_electronics() {
  if (product_type_case() != kElectronics) {
    clear_product_type();
    set_has_electronics();
    _impl_.product_type_.electronics_ = CreateMaybeMessage<::com::cps2004::Electronics>(GetArena());
  }
  return _impl_.product_type_.electronics_;
}
inline ::com::cps2004::Electronics* Product::mutable_electronics() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::cps2004::Electronics* _msg = _internal_mutable_electronics();
  // @@protoc_insertion_point(field_mutable:com.cps2004.Product.electronics)
  return _msg;
}

// .com.cps2004.Food food = 3;
inline bool Product::has_food() const {
  return product_type_case() == kFood;
}
inline bool Product::_internal_has_food() const {
  return product_type_case() == kFood;
}
inline void Product::set_has_food() {
  _impl_._oneof_case_[0] = kFood;
}
inline void Product::clear_food() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (product_type_case() == kFood) {
    if (GetArena() == nullptr) {
      delete _impl_.product_type_.food_;
    }
    clear_has_product_type();
  }
}
inline ::com::cps2004::Food* Product::release_food() {
  // @@protoc_insertion_point(field_release:com.cps2004.Product.food)
  if (product_type_case() == kFood) {
    clear_has_product_type();
    auto* temp = _impl_.product_type_.food_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.product_type_.food_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::com::cps2004::Food& Product::_internal_food() const {
  return product_type_case() == kFood ? *_impl_.product_type_.food_ : reinterpret_cast<::com::cps2004::Food&>(::com::cps2004::_Food_default_instance_);
}
inline const ::com::cps2004::Food& Product::food() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Product.food)
  return _internal_food();
}
inline ::com::cps2004::Food* Product::unsafe_arena_release_food() {
  // @@protoc_insertion_point(field_unsafe_arena_release:com.cps2004.Product.food)
  if (product_type_case() == kFood) {
    clear_has_product_type();
    auto* temp = _impl_.product_type_.food_;
    _impl_.product_type_.food_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Product::unsafe_arena_set_allocated_food(::com::cps2004::Food* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_product_type();
  if (value) {
    set_has_food();
    _impl_.product_type_.food_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.cps2004.Product.food)
}
inline ::com::cps2004::Food* Product::_internal_mutable_food() {
  if (product_type_case() != kFood) {
    clear_product_type();
    set_has_food();
    _impl_.product_type_.food_ = CreateMaybeMessage<::com::cps2004::Food>(GetArena());
  }
  return _impl_.product_type_.food_;
}
inline ::com::cps2004::Food* Product::mutable_food() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::cps2004::Food* _msg = _internal_mutable_food();
  // @@protoc_insertion_point(field_mutable:com.cps2004.Product.food)
  return _msg;
}

// .com.cps2004.Clothes clothes = 4;
inline bool Product::has_clothes() const {
  return product_type_case() == kClothes;
}
inline bool Product::_internal_has_clothes() const {
  return product_type_case() == kClothes;
}
inline void Product::set_has_clothes() {
  _impl_._oneof_case_[0] = kClothes;
}
inline void Product::clear_clothes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (product_type_case() == kClothes) {
    if (GetArena() == nullptr) {
      delete _impl_.product_type_.clothes_;
    }
    clear_has_product_type();
  }
}
inline ::com::cps2004::Clothes* Product::release_clothes() {
  // @@protoc_insertion_point(field_release:com.cps2004.Product.clothes)
  if (product_type_case() == kClothes) {
    clear_has_product_type();
    auto* temp = _impl_.product_type_.clothes_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.product_type_.clothes_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::com::cps2004::Clothes& Product::_internal_clothes() const {
  return product_type_case() == kClothes ? *_impl_.product_type_.clothes_ : reinterpret_cast<::com::cps2004::Clothes&>(::com::cps2004::_Clothes_default_instance_);
}
inline const ::com::cps2004::Clothes& Product::clothes() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Product.clothes)
  return _internal_clothes();
}
inline ::com::cps2004::Clothes* Product::unsafe_arena_release_clothes() {
  // @@protoc_insertion_point(field_unsafe_arena_release:com.cps2004.Product.clothes)
  if (product_type_case() == kClothes) {
    clear_has_product_type();
    auto* temp = _impl_.product_type_.clothes_;
    _impl_.product_type_.clothes_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Product::unsafe_arena_set_allocated_clothes(::com::cps2004::Clothes* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_product_type();
  if (value) {
    set_has_clothes();
    _impl_.product_type_.clothes_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.cps2004.Product.clothes)
}
inline ::com::cps2004::Clothes* Product::_internal_mutable_clothes() {
  if (product_type_case() != kClothes) {
    clear_product_type();
    set_has_clothes();
    _impl_.product_type_.clothes_ = CreateMaybeMessage<::com::cps2004::Clothes>(GetArena());
  }
  return _impl_.product_type_.clothes_;
}
inline ::com::cps2004::Clothes* Product::mutable_clothes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::cps2004::Clothes* _msg = _internal_mutable_clothes();
  // @@protoc_insertion_point(field_mutable:com.cps2004.Product.clothes)
  return _msg;
}

// .com.cps2004.Furniture furniture = 5;
inline bool Product::has_furniture() const {
  return product_type_case() == kFurniture;
}
inline bool Product::_internal_has_furniture() const {
  return product_type_case() == kFurniture;
}
inline void Product::set_has_furniture() {
  _impl_._oneof_case_[0] = kFurniture;
}
inline void Product::clear_furniture() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (product_type_case() == kFurniture) {
    if (GetArena() == nullptr) {
      delete _impl_.product_type_.furniture_;
    }
    clear_has_product_type();
  }
}
inline ::com::cps2004::Furniture* Product::release_furniture() {
  // @@protoc_insertion_point(field_release:com.cps2004.Product.furniture)
  if (product_type_case() == kFurniture) {
    clear_has_product_type();
    auto* temp = _impl_.product_type_.furniture_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.product_type_.furniture_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::com::cps2004::Furniture& Product::_internal_furniture() const {
  return product_type_case() == kFurniture ? *_impl_.product_type_.furniture_ : reinterpret_cast<::com::cps2004::Furniture&>(::com::cps2004::_Furniture_default_instance_);
}
inline const ::com::cps2004::Furniture& Product::furniture() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Product.furniture)
  return _internal_furniture();
}
inline ::com::cps2004::Furniture* Product::unsafe_arena_release_furniture() {
  // @@protoc_insertion_point(field_unsafe_arena_release:com.cps2004.Product.furniture)
  if (product_type_case() == kFurniture) {
    clear_has_product_type();
    auto* temp = _impl_.product_type_.furniture_;
    _impl_.product_type_.furniture_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Product::unsafe_arena_set_allocated_furniture(::com::cps2004::Furniture* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_product_type();
  if (value) {
    set_has_furniture();
    _impl_.product_type_.furniture_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.cps2004.Product.furniture)
}
inline ::com::cps2004::Furniture* Product::_internal_mutable_furniture() {
  if (product_type_case() != kFurniture) {
    clear_product_type();
    set_has_furniture();
    _impl_.product_type_.furniture_ = CreateMaybeMessage<::com::cps2004::Furniture>(GetArena());
  }
  return _impl_.product_type_.furniture_;
}
inline ::com::cps2004::Furniture* Product::mutable_furniture() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::cps2004::Furniture* _msg = _internal_mutable_furniture();
  // @@protoc_insertion_point(field_mutable:com.cps2004.Product.furniture)
  return _msg;
}

// .com.cps2004.VideoGame videoGame = 6;
inline bool Product::has_videogame() const {
  return product_type_case() == kVideoGame;
}
inline bool Product::_internal_has_videogame() const {
  return product_type_case() == kVideoGame;
}
inline void Product::set_has_videogame() {
  _impl_._oneof_case_[0] = kVideoGame;
}
inline void Product::clear_videogame() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (product_type_case() == kVideoGame) {
    if (GetArena() == nullptr) {
      delete _impl_.product_type_.videogame_;
    }
    clear_has_product_type();
  }
}
inline ::com::cps2004::VideoGame* Product::release_videogame() {
  // @@protoc_insertion_point(field_release:com.cps2004.Product.videoGame)
  if (product_type_case() == kVideoGame) {
    clear_has_product_type();
    auto* temp = _impl_.product_type_.videogame_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.product_type_.videogame_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::com::cps2004::VideoGame& Product::_internal_videogame() const {
  return product_type_case() == kVideoGame ? *_impl_.product_type_.videogame_ : reinterpret_cast<::com::cps2004::VideoGame&>(::com::cps2004::_VideoGame_default_instance_);
}
inline const ::com::cps2004::VideoGame& Product::videogame() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Product.videoGame)
  return _internal_videogame();
}
inline ::com::cps2004::VideoGame* Product::unsafe_arena_release_videogame() {
  // @@protoc_insertion_point(field_unsafe_arena_release:com.cps2004.Product.videoGame)
  if (product_type_case() == kVideoGame) {
    clear_has_product_type();
    auto* temp = _impl_.product_type_.videogame_;
    _impl_.product_type_.videogame_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Product::unsafe_arena_set_allocated_videogame(::com::cps2004::VideoGame* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_product_type();
  if (value) {
    set_has_videogame();
    _impl_.product_type_.videogame_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.cps2004.Product.videoGame)
}
inline ::com::cps2004::VideoGame* Product::_internal_mutable_videogame() {
  if (product_type_case() != kVideoGame) {
    clear_product_type();
    set_has_videogame();
    _impl_.product_type_.videogame_ = CreateMaybeMessage<::com::cps2004::VideoGame>(GetArena());
  }
  return _impl_.product_type_.videogame_;
}
inline ::com::cps2004::VideoGame* Product::mutable_videogame() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::cps2004::VideoGame* _msg = _internal_mutable_videogame();
  // @@protoc_insertion_point(field_mutable:com.cps2004.Product.videoGame)
  return _msg;
}

// string name = 7;
inline void Product::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Product::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Product.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Product::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:com.cps2004.Product.name)
}
inline std::string* Product::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:com.cps2004.Product.name)
  return _s;
}
inline const std::string& Product::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void Product::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Product::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Product::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.cps2004.Product.name)
  return _impl_.name_.Release();
}
inline void Product::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.cps2004.Product.name)
}

// int32 productID = 8;
inline void Product::clear_productid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.productid_ = 0;
}
inline ::int32_t Product::productid() const {
  // @@protoc_insertion_point(field_get:com.cps2004.Product.productID)
  return _internal_productid();
}
inline void Product::set_productid(::int32_t value) {
  _internal_set_productid(value);
  // @@protoc_insertion_point(field_set:com.cps2004.Product.productID)
}
inline ::int32_t Product::_internal_productid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.productid_;
}
inline void Product::_internal_set_productid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.productid_ = value;
}

// int32 price = 9;
inline void Product::clear_price() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.price_ = 0;
}
inline ::int32_t Product::price() const {
  // @@protoc_insertion_point(field_get:com.cps2004.Product.price)
  return _internal_price();
}
inline void Product::set_price(::int32_t value) {
  _internal_set_price(value);
  // @@protoc_insertion_point(field_set:com.cps2004.Product.price)
}
inline ::int32_t Product::_internal_price() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.price_;
}
inline void Product::_internal_set_price(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.price_ = value;
}

// int32 quantity = 10;
inline void Product::clear_quantity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.quantity_ = 0;
}
inline ::int32_t Product::quantity() const {
  // @@protoc_insertion_point(field_get:com.cps2004.Product.quantity)
  return _internal_quantity();
}
inline void Product::set_quantity(::int32_t value) {
  _internal_set_quantity(value);
  // @@protoc_insertion_point(field_set:com.cps2004.Product.quantity)
}
inline ::int32_t Product::_internal_quantity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.quantity_;
}
inline void Product::_internal_set_quantity(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.quantity_ = value;
}

// .com.cps2004.Supplier supplier = 11;
inline bool Product::has_supplier() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.supplier_ != nullptr);
  return value;
}
inline void Product::clear_supplier() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.supplier_ != nullptr) _impl_.supplier_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::com::cps2004::Supplier& Product::_internal_supplier() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::cps2004::Supplier* p = _impl_.supplier_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::cps2004::Supplier&>(::com::cps2004::_Supplier_default_instance_);
}
inline const ::com::cps2004::Supplier& Product::supplier() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Product.supplier)
  return _internal_supplier();
}
inline void Product::unsafe_arena_set_allocated_supplier(::com::cps2004::Supplier* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.supplier_);
  }
  _impl_.supplier_ = reinterpret_cast<::com::cps2004::Supplier*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.cps2004.Product.supplier)
}
inline ::com::cps2004::Supplier* Product::release_supplier() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::cps2004::Supplier* released = _impl_.supplier_;
  _impl_.supplier_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::cps2004::Supplier* Product::unsafe_arena_release_supplier() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.cps2004.Product.supplier)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::cps2004::Supplier* temp = _impl_.supplier_;
  _impl_.supplier_ = nullptr;
  return temp;
}
inline ::com::cps2004::Supplier* Product::_internal_mutable_supplier() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.supplier_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::cps2004::Supplier>(GetArena());
    _impl_.supplier_ = reinterpret_cast<::com::cps2004::Supplier*>(p);
  }
  return _impl_.supplier_;
}
inline ::com::cps2004::Supplier* Product::mutable_supplier() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::cps2004::Supplier* _msg = _internal_mutable_supplier();
  // @@protoc_insertion_point(field_mutable:com.cps2004.Product.supplier)
  return _msg;
}
inline void Product::set_allocated_supplier(::com::cps2004::Supplier* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::cps2004::Supplier*>(_impl_.supplier_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::cps2004::Supplier*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.supplier_ = reinterpret_cast<::com::cps2004::Supplier*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.cps2004.Product.supplier)
}

// int32 volume = 12;
inline void Product::clear_volume() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.volume_ = 0;
}
inline ::int32_t Product::volume() const {
  // @@protoc_insertion_point(field_get:com.cps2004.Product.volume)
  return _internal_volume();
}
inline void Product::set_volume(::int32_t value) {
  _internal_set_volume(value);
  // @@protoc_insertion_point(field_set:com.cps2004.Product.volume)
}
inline ::int32_t Product::_internal_volume() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.volume_;
}
inline void Product::_internal_set_volume(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.volume_ = value;
}

inline bool Product::has_product_type() const {
  return product_type_case() != PRODUCT_TYPE_NOT_SET;
}
inline void Product::clear_has_product_type() {
  _impl_._oneof_case_[0] = PRODUCT_TYPE_NOT_SET;
}
inline Product::ProductTypeCase Product::product_type_case() const {
  return Product::ProductTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Book

// .com.cps2004.FictionBook fictionBook = 1;
inline bool Book::has_fictionbook() const {
  return book_type_case() == kFictionBook;
}
inline bool Book::_internal_has_fictionbook() const {
  return book_type_case() == kFictionBook;
}
inline void Book::set_has_fictionbook() {
  _impl_._oneof_case_[0] = kFictionBook;
}
inline void Book::clear_fictionbook() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (book_type_case() == kFictionBook) {
    if (GetArena() == nullptr) {
      delete _impl_.book_type_.fictionbook_;
    }
    clear_has_book_type();
  }
}
inline ::com::cps2004::FictionBook* Book::release_fictionbook() {
  // @@protoc_insertion_point(field_release:com.cps2004.Book.fictionBook)
  if (book_type_case() == kFictionBook) {
    clear_has_book_type();
    auto* temp = _impl_.book_type_.fictionbook_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.book_type_.fictionbook_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::com::cps2004::FictionBook& Book::_internal_fictionbook() const {
  return book_type_case() == kFictionBook ? *_impl_.book_type_.fictionbook_ : reinterpret_cast<::com::cps2004::FictionBook&>(::com::cps2004::_FictionBook_default_instance_);
}
inline const ::com::cps2004::FictionBook& Book::fictionbook() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Book.fictionBook)
  return _internal_fictionbook();
}
inline ::com::cps2004::FictionBook* Book::unsafe_arena_release_fictionbook() {
  // @@protoc_insertion_point(field_unsafe_arena_release:com.cps2004.Book.fictionBook)
  if (book_type_case() == kFictionBook) {
    clear_has_book_type();
    auto* temp = _impl_.book_type_.fictionbook_;
    _impl_.book_type_.fictionbook_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Book::unsafe_arena_set_allocated_fictionbook(::com::cps2004::FictionBook* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_book_type();
  if (value) {
    set_has_fictionbook();
    _impl_.book_type_.fictionbook_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.cps2004.Book.fictionBook)
}
inline ::com::cps2004::FictionBook* Book::_internal_mutable_fictionbook() {
  if (book_type_case() != kFictionBook) {
    clear_book_type();
    set_has_fictionbook();
    _impl_.book_type_.fictionbook_ = CreateMaybeMessage<::com::cps2004::FictionBook>(GetArena());
  }
  return _impl_.book_type_.fictionbook_;
}
inline ::com::cps2004::FictionBook* Book::mutable_fictionbook() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::cps2004::FictionBook* _msg = _internal_mutable_fictionbook();
  // @@protoc_insertion_point(field_mutable:com.cps2004.Book.fictionBook)
  return _msg;
}

// .com.cps2004.Textbook textbook = 2;
inline bool Book::has_textbook() const {
  return book_type_case() == kTextbook;
}
inline bool Book::_internal_has_textbook() const {
  return book_type_case() == kTextbook;
}
inline void Book::set_has_textbook() {
  _impl_._oneof_case_[0] = kTextbook;
}
inline void Book::clear_textbook() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (book_type_case() == kTextbook) {
    if (GetArena() == nullptr) {
      delete _impl_.book_type_.textbook_;
    }
    clear_has_book_type();
  }
}
inline ::com::cps2004::Textbook* Book::release_textbook() {
  // @@protoc_insertion_point(field_release:com.cps2004.Book.textbook)
  if (book_type_case() == kTextbook) {
    clear_has_book_type();
    auto* temp = _impl_.book_type_.textbook_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.book_type_.textbook_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::com::cps2004::Textbook& Book::_internal_textbook() const {
  return book_type_case() == kTextbook ? *_impl_.book_type_.textbook_ : reinterpret_cast<::com::cps2004::Textbook&>(::com::cps2004::_Textbook_default_instance_);
}
inline const ::com::cps2004::Textbook& Book::textbook() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Book.textbook)
  return _internal_textbook();
}
inline ::com::cps2004::Textbook* Book::unsafe_arena_release_textbook() {
  // @@protoc_insertion_point(field_unsafe_arena_release:com.cps2004.Book.textbook)
  if (book_type_case() == kTextbook) {
    clear_has_book_type();
    auto* temp = _impl_.book_type_.textbook_;
    _impl_.book_type_.textbook_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Book::unsafe_arena_set_allocated_textbook(::com::cps2004::Textbook* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_book_type();
  if (value) {
    set_has_textbook();
    _impl_.book_type_.textbook_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.cps2004.Book.textbook)
}
inline ::com::cps2004::Textbook* Book::_internal_mutable_textbook() {
  if (book_type_case() != kTextbook) {
    clear_book_type();
    set_has_textbook();
    _impl_.book_type_.textbook_ = CreateMaybeMessage<::com::cps2004::Textbook>(GetArena());
  }
  return _impl_.book_type_.textbook_;
}
inline ::com::cps2004::Textbook* Book::mutable_textbook() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::cps2004::Textbook* _msg = _internal_mutable_textbook();
  // @@protoc_insertion_point(field_mutable:com.cps2004.Book.textbook)
  return _msg;
}

// .com.cps2004.Product product = 3;
inline bool Book::has_product() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.product_ != nullptr);
  return value;
}
inline void Book::clear_product() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.product_ != nullptr) _impl_.product_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::com::cps2004::Product& Book::_internal_product() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::cps2004::Product* p = _impl_.product_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::cps2004::Product&>(::com::cps2004::_Product_default_instance_);
}
inline const ::com::cps2004::Product& Book::product() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Book.product)
  return _internal_product();
}
inline void Book::unsafe_arena_set_allocated_product(::com::cps2004::Product* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.product_);
  }
  _impl_.product_ = reinterpret_cast<::com::cps2004::Product*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.cps2004.Book.product)
}
inline ::com::cps2004::Product* Book::release_product() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::cps2004::Product* released = _impl_.product_;
  _impl_.product_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::cps2004::Product* Book::unsafe_arena_release_product() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.cps2004.Book.product)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::cps2004::Product* temp = _impl_.product_;
  _impl_.product_ = nullptr;
  return temp;
}
inline ::com::cps2004::Product* Book::_internal_mutable_product() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.product_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::cps2004::Product>(GetArena());
    _impl_.product_ = reinterpret_cast<::com::cps2004::Product*>(p);
  }
  return _impl_.product_;
}
inline ::com::cps2004::Product* Book::mutable_product() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::cps2004::Product* _msg = _internal_mutable_product();
  // @@protoc_insertion_point(field_mutable:com.cps2004.Book.product)
  return _msg;
}
inline void Book::set_allocated_product(::com::cps2004::Product* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::cps2004::Product*>(_impl_.product_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::cps2004::Product*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.product_ = reinterpret_cast<::com::cps2004::Product*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.cps2004.Book.product)
}

// string publisher = 4;
inline void Book::clear_publisher() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.publisher_.ClearToEmpty();
}
inline const std::string& Book::publisher() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Book.publisher)
  return _internal_publisher();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Book::set_publisher(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.publisher_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:com.cps2004.Book.publisher)
}
inline std::string* Book::mutable_publisher() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_publisher();
  // @@protoc_insertion_point(field_mutable:com.cps2004.Book.publisher)
  return _s;
}
inline const std::string& Book::_internal_publisher() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.publisher_.Get();
}
inline void Book::_internal_set_publisher(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.publisher_.Set(value, GetArena());
}
inline std::string* Book::_internal_mutable_publisher() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.publisher_.Mutable( GetArena());
}
inline std::string* Book::release_publisher() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.cps2004.Book.publisher)
  return _impl_.publisher_.Release();
}
inline void Book::set_allocated_publisher(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.publisher_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.publisher_.IsDefault()) {
          _impl_.publisher_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.cps2004.Book.publisher)
}

// int32 pages = 5;
inline void Book::clear_pages() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pages_ = 0;
}
inline ::int32_t Book::pages() const {
  // @@protoc_insertion_point(field_get:com.cps2004.Book.pages)
  return _internal_pages();
}
inline void Book::set_pages(::int32_t value) {
  _internal_set_pages(value);
  // @@protoc_insertion_point(field_set:com.cps2004.Book.pages)
}
inline ::int32_t Book::_internal_pages() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pages_;
}
inline void Book::_internal_set_pages(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.pages_ = value;
}

// string author = 6;
inline void Book::clear_author() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.author_.ClearToEmpty();
}
inline const std::string& Book::author() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Book.author)
  return _internal_author();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Book::set_author(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.author_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:com.cps2004.Book.author)
}
inline std::string* Book::mutable_author() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_author();
  // @@protoc_insertion_point(field_mutable:com.cps2004.Book.author)
  return _s;
}
inline const std::string& Book::_internal_author() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.author_.Get();
}
inline void Book::_internal_set_author(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.author_.Set(value, GetArena());
}
inline std::string* Book::_internal_mutable_author() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.author_.Mutable( GetArena());
}
inline std::string* Book::release_author() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.cps2004.Book.author)
  return _impl_.author_.Release();
}
inline void Book::set_allocated_author(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.author_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.author_.IsDefault()) {
          _impl_.author_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.cps2004.Book.author)
}

inline bool Book::has_book_type() const {
  return book_type_case() != BOOK_TYPE_NOT_SET;
}
inline void Book::clear_has_book_type() {
  _impl_._oneof_case_[0] = BOOK_TYPE_NOT_SET;
}
inline Book::BookTypeCase Book::book_type_case() const {
  return Book::BookTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// FictionBook

// .com.cps2004.Book book = 1;
inline bool FictionBook::has_book() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.book_ != nullptr);
  return value;
}
inline void FictionBook::clear_book() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.book_ != nullptr) _impl_.book_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::com::cps2004::Book& FictionBook::_internal_book() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::cps2004::Book* p = _impl_.book_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::cps2004::Book&>(::com::cps2004::_Book_default_instance_);
}
inline const ::com::cps2004::Book& FictionBook::book() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.FictionBook.book)
  return _internal_book();
}
inline void FictionBook::unsafe_arena_set_allocated_book(::com::cps2004::Book* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.book_);
  }
  _impl_.book_ = reinterpret_cast<::com::cps2004::Book*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.cps2004.FictionBook.book)
}
inline ::com::cps2004::Book* FictionBook::release_book() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::cps2004::Book* released = _impl_.book_;
  _impl_.book_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::cps2004::Book* FictionBook::unsafe_arena_release_book() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.cps2004.FictionBook.book)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::cps2004::Book* temp = _impl_.book_;
  _impl_.book_ = nullptr;
  return temp;
}
inline ::com::cps2004::Book* FictionBook::_internal_mutable_book() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.book_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::cps2004::Book>(GetArena());
    _impl_.book_ = reinterpret_cast<::com::cps2004::Book*>(p);
  }
  return _impl_.book_;
}
inline ::com::cps2004::Book* FictionBook::mutable_book() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::cps2004::Book* _msg = _internal_mutable_book();
  // @@protoc_insertion_point(field_mutable:com.cps2004.FictionBook.book)
  return _msg;
}
inline void FictionBook::set_allocated_book(::com::cps2004::Book* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::cps2004::Book*>(_impl_.book_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::cps2004::Book*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.book_ = reinterpret_cast<::com::cps2004::Book*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.cps2004.FictionBook.book)
}

// string genre = 2;
inline void FictionBook::clear_genre() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.genre_.ClearToEmpty();
}
inline const std::string& FictionBook::genre() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.FictionBook.genre)
  return _internal_genre();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FictionBook::set_genre(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.genre_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:com.cps2004.FictionBook.genre)
}
inline std::string* FictionBook::mutable_genre() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_genre();
  // @@protoc_insertion_point(field_mutable:com.cps2004.FictionBook.genre)
  return _s;
}
inline const std::string& FictionBook::_internal_genre() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.genre_.Get();
}
inline void FictionBook::_internal_set_genre(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.genre_.Set(value, GetArena());
}
inline std::string* FictionBook::_internal_mutable_genre() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.genre_.Mutable( GetArena());
}
inline std::string* FictionBook::release_genre() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.cps2004.FictionBook.genre)
  return _impl_.genre_.Release();
}
inline void FictionBook::set_allocated_genre(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.genre_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.genre_.IsDefault()) {
          _impl_.genre_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.cps2004.FictionBook.genre)
}

// string publicationDate = 3;
inline void FictionBook::clear_publicationdate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.publicationdate_.ClearToEmpty();
}
inline const std::string& FictionBook::publicationdate() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.FictionBook.publicationDate)
  return _internal_publicationdate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FictionBook::set_publicationdate(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.publicationdate_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:com.cps2004.FictionBook.publicationDate)
}
inline std::string* FictionBook::mutable_publicationdate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_publicationdate();
  // @@protoc_insertion_point(field_mutable:com.cps2004.FictionBook.publicationDate)
  return _s;
}
inline const std::string& FictionBook::_internal_publicationdate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.publicationdate_.Get();
}
inline void FictionBook::_internal_set_publicationdate(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.publicationdate_.Set(value, GetArena());
}
inline std::string* FictionBook::_internal_mutable_publicationdate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.publicationdate_.Mutable( GetArena());
}
inline std::string* FictionBook::release_publicationdate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.cps2004.FictionBook.publicationDate)
  return _impl_.publicationdate_.Release();
}
inline void FictionBook::set_allocated_publicationdate(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.publicationdate_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.publicationdate_.IsDefault()) {
          _impl_.publicationdate_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.cps2004.FictionBook.publicationDate)
}

// -------------------------------------------------------------------

// Textbook

// .com.cps2004.Book book = 1;
inline bool Textbook::has_book() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.book_ != nullptr);
  return value;
}
inline void Textbook::clear_book() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.book_ != nullptr) _impl_.book_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::com::cps2004::Book& Textbook::_internal_book() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::cps2004::Book* p = _impl_.book_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::cps2004::Book&>(::com::cps2004::_Book_default_instance_);
}
inline const ::com::cps2004::Book& Textbook::book() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Textbook.book)
  return _internal_book();
}
inline void Textbook::unsafe_arena_set_allocated_book(::com::cps2004::Book* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.book_);
  }
  _impl_.book_ = reinterpret_cast<::com::cps2004::Book*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.cps2004.Textbook.book)
}
inline ::com::cps2004::Book* Textbook::release_book() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::cps2004::Book* released = _impl_.book_;
  _impl_.book_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::cps2004::Book* Textbook::unsafe_arena_release_book() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.cps2004.Textbook.book)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::cps2004::Book* temp = _impl_.book_;
  _impl_.book_ = nullptr;
  return temp;
}
inline ::com::cps2004::Book* Textbook::_internal_mutable_book() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.book_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::cps2004::Book>(GetArena());
    _impl_.book_ = reinterpret_cast<::com::cps2004::Book*>(p);
  }
  return _impl_.book_;
}
inline ::com::cps2004::Book* Textbook::mutable_book() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::cps2004::Book* _msg = _internal_mutable_book();
  // @@protoc_insertion_point(field_mutable:com.cps2004.Textbook.book)
  return _msg;
}
inline void Textbook::set_allocated_book(::com::cps2004::Book* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::cps2004::Book*>(_impl_.book_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::cps2004::Book*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.book_ = reinterpret_cast<::com::cps2004::Book*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.cps2004.Textbook.book)
}

// string subject = 2;
inline void Textbook::clear_subject() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.subject_.ClearToEmpty();
}
inline const std::string& Textbook::subject() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Textbook.subject)
  return _internal_subject();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Textbook::set_subject(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.subject_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:com.cps2004.Textbook.subject)
}
inline std::string* Textbook::mutable_subject() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_subject();
  // @@protoc_insertion_point(field_mutable:com.cps2004.Textbook.subject)
  return _s;
}
inline const std::string& Textbook::_internal_subject() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.subject_.Get();
}
inline void Textbook::_internal_set_subject(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.subject_.Set(value, GetArena());
}
inline std::string* Textbook::_internal_mutable_subject() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.subject_.Mutable( GetArena());
}
inline std::string* Textbook::release_subject() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.cps2004.Textbook.subject)
  return _impl_.subject_.Release();
}
inline void Textbook::set_allocated_subject(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.subject_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subject_.IsDefault()) {
          _impl_.subject_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.cps2004.Textbook.subject)
}

// int32 edition = 3;
inline void Textbook::clear_edition() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.edition_ = 0;
}
inline ::int32_t Textbook::edition() const {
  // @@protoc_insertion_point(field_get:com.cps2004.Textbook.edition)
  return _internal_edition();
}
inline void Textbook::set_edition(::int32_t value) {
  _internal_set_edition(value);
  // @@protoc_insertion_point(field_set:com.cps2004.Textbook.edition)
}
inline ::int32_t Textbook::_internal_edition() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.edition_;
}
inline void Textbook::_internal_set_edition(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.edition_ = value;
}

// -------------------------------------------------------------------

// Electronics

// .com.cps2004.Camera camera = 1;
inline bool Electronics::has_camera() const {
  return electronics_type_case() == kCamera;
}
inline bool Electronics::_internal_has_camera() const {
  return electronics_type_case() == kCamera;
}
inline void Electronics::set_has_camera() {
  _impl_._oneof_case_[0] = kCamera;
}
inline void Electronics::clear_camera() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (electronics_type_case() == kCamera) {
    if (GetArena() == nullptr) {
      delete _impl_.electronics_type_.camera_;
    }
    clear_has_electronics_type();
  }
}
inline ::com::cps2004::Camera* Electronics::release_camera() {
  // @@protoc_insertion_point(field_release:com.cps2004.Electronics.camera)
  if (electronics_type_case() == kCamera) {
    clear_has_electronics_type();
    auto* temp = _impl_.electronics_type_.camera_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.electronics_type_.camera_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::com::cps2004::Camera& Electronics::_internal_camera() const {
  return electronics_type_case() == kCamera ? *_impl_.electronics_type_.camera_ : reinterpret_cast<::com::cps2004::Camera&>(::com::cps2004::_Camera_default_instance_);
}
inline const ::com::cps2004::Camera& Electronics::camera() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Electronics.camera)
  return _internal_camera();
}
inline ::com::cps2004::Camera* Electronics::unsafe_arena_release_camera() {
  // @@protoc_insertion_point(field_unsafe_arena_release:com.cps2004.Electronics.camera)
  if (electronics_type_case() == kCamera) {
    clear_has_electronics_type();
    auto* temp = _impl_.electronics_type_.camera_;
    _impl_.electronics_type_.camera_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Electronics::unsafe_arena_set_allocated_camera(::com::cps2004::Camera* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_electronics_type();
  if (value) {
    set_has_camera();
    _impl_.electronics_type_.camera_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.cps2004.Electronics.camera)
}
inline ::com::cps2004::Camera* Electronics::_internal_mutable_camera() {
  if (electronics_type_case() != kCamera) {
    clear_electronics_type();
    set_has_camera();
    _impl_.electronics_type_.camera_ = CreateMaybeMessage<::com::cps2004::Camera>(GetArena());
  }
  return _impl_.electronics_type_.camera_;
}
inline ::com::cps2004::Camera* Electronics::mutable_camera() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::cps2004::Camera* _msg = _internal_mutable_camera();
  // @@protoc_insertion_point(field_mutable:com.cps2004.Electronics.camera)
  return _msg;
}

// .com.cps2004.Laptop laptop = 2;
inline bool Electronics::has_laptop() const {
  return electronics_type_case() == kLaptop;
}
inline bool Electronics::_internal_has_laptop() const {
  return electronics_type_case() == kLaptop;
}
inline void Electronics::set_has_laptop() {
  _impl_._oneof_case_[0] = kLaptop;
}
inline void Electronics::clear_laptop() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (electronics_type_case() == kLaptop) {
    if (GetArena() == nullptr) {
      delete _impl_.electronics_type_.laptop_;
    }
    clear_has_electronics_type();
  }
}
inline ::com::cps2004::Laptop* Electronics::release_laptop() {
  // @@protoc_insertion_point(field_release:com.cps2004.Electronics.laptop)
  if (electronics_type_case() == kLaptop) {
    clear_has_electronics_type();
    auto* temp = _impl_.electronics_type_.laptop_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.electronics_type_.laptop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::com::cps2004::Laptop& Electronics::_internal_laptop() const {
  return electronics_type_case() == kLaptop ? *_impl_.electronics_type_.laptop_ : reinterpret_cast<::com::cps2004::Laptop&>(::com::cps2004::_Laptop_default_instance_);
}
inline const ::com::cps2004::Laptop& Electronics::laptop() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Electronics.laptop)
  return _internal_laptop();
}
inline ::com::cps2004::Laptop* Electronics::unsafe_arena_release_laptop() {
  // @@protoc_insertion_point(field_unsafe_arena_release:com.cps2004.Electronics.laptop)
  if (electronics_type_case() == kLaptop) {
    clear_has_electronics_type();
    auto* temp = _impl_.electronics_type_.laptop_;
    _impl_.electronics_type_.laptop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Electronics::unsafe_arena_set_allocated_laptop(::com::cps2004::Laptop* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_electronics_type();
  if (value) {
    set_has_laptop();
    _impl_.electronics_type_.laptop_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.cps2004.Electronics.laptop)
}
inline ::com::cps2004::Laptop* Electronics::_internal_mutable_laptop() {
  if (electronics_type_case() != kLaptop) {
    clear_electronics_type();
    set_has_laptop();
    _impl_.electronics_type_.laptop_ = CreateMaybeMessage<::com::cps2004::Laptop>(GetArena());
  }
  return _impl_.electronics_type_.laptop_;
}
inline ::com::cps2004::Laptop* Electronics::mutable_laptop() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::cps2004::Laptop* _msg = _internal_mutable_laptop();
  // @@protoc_insertion_point(field_mutable:com.cps2004.Electronics.laptop)
  return _msg;
}

// .com.cps2004.Product product = 3;
inline bool Electronics::has_product() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.product_ != nullptr);
  return value;
}
inline void Electronics::clear_product() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.product_ != nullptr) _impl_.product_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::com::cps2004::Product& Electronics::_internal_product() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::cps2004::Product* p = _impl_.product_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::cps2004::Product&>(::com::cps2004::_Product_default_instance_);
}
inline const ::com::cps2004::Product& Electronics::product() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Electronics.product)
  return _internal_product();
}
inline void Electronics::unsafe_arena_set_allocated_product(::com::cps2004::Product* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.product_);
  }
  _impl_.product_ = reinterpret_cast<::com::cps2004::Product*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.cps2004.Electronics.product)
}
inline ::com::cps2004::Product* Electronics::release_product() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::cps2004::Product* released = _impl_.product_;
  _impl_.product_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::cps2004::Product* Electronics::unsafe_arena_release_product() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.cps2004.Electronics.product)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::cps2004::Product* temp = _impl_.product_;
  _impl_.product_ = nullptr;
  return temp;
}
inline ::com::cps2004::Product* Electronics::_internal_mutable_product() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.product_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::cps2004::Product>(GetArena());
    _impl_.product_ = reinterpret_cast<::com::cps2004::Product*>(p);
  }
  return _impl_.product_;
}
inline ::com::cps2004::Product* Electronics::mutable_product() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::cps2004::Product* _msg = _internal_mutable_product();
  // @@protoc_insertion_point(field_mutable:com.cps2004.Electronics.product)
  return _msg;
}
inline void Electronics::set_allocated_product(::com::cps2004::Product* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::cps2004::Product*>(_impl_.product_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::cps2004::Product*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.product_ = reinterpret_cast<::com::cps2004::Product*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.cps2004.Electronics.product)
}

// string manufacturer = 4;
inline void Electronics::clear_manufacturer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.manufacturer_.ClearToEmpty();
}
inline const std::string& Electronics::manufacturer() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Electronics.manufacturer)
  return _internal_manufacturer();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Electronics::set_manufacturer(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.manufacturer_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:com.cps2004.Electronics.manufacturer)
}
inline std::string* Electronics::mutable_manufacturer() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_manufacturer();
  // @@protoc_insertion_point(field_mutable:com.cps2004.Electronics.manufacturer)
  return _s;
}
inline const std::string& Electronics::_internal_manufacturer() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.manufacturer_.Get();
}
inline void Electronics::_internal_set_manufacturer(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.manufacturer_.Set(value, GetArena());
}
inline std::string* Electronics::_internal_mutable_manufacturer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.manufacturer_.Mutable( GetArena());
}
inline std::string* Electronics::release_manufacturer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.cps2004.Electronics.manufacturer)
  return _impl_.manufacturer_.Release();
}
inline void Electronics::set_allocated_manufacturer(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.manufacturer_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.manufacturer_.IsDefault()) {
          _impl_.manufacturer_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.cps2004.Electronics.manufacturer)
}

// int32 warranty = 5;
inline void Electronics::clear_warranty() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.warranty_ = 0;
}
inline ::int32_t Electronics::warranty() const {
  // @@protoc_insertion_point(field_get:com.cps2004.Electronics.warranty)
  return _internal_warranty();
}
inline void Electronics::set_warranty(::int32_t value) {
  _internal_set_warranty(value);
  // @@protoc_insertion_point(field_set:com.cps2004.Electronics.warranty)
}
inline ::int32_t Electronics::_internal_warranty() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.warranty_;
}
inline void Electronics::_internal_set_warranty(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.warranty_ = value;
}

inline bool Electronics::has_electronics_type() const {
  return electronics_type_case() != ELECTRONICS_TYPE_NOT_SET;
}
inline void Electronics::clear_has_electronics_type() {
  _impl_._oneof_case_[0] = ELECTRONICS_TYPE_NOT_SET;
}
inline Electronics::ElectronicsTypeCase Electronics::electronics_type_case() const {
  return Electronics::ElectronicsTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Camera

// .com.cps2004.Electronics electronics = 1;
inline bool Camera::has_electronics() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.electronics_ != nullptr);
  return value;
}
inline void Camera::clear_electronics() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.electronics_ != nullptr) _impl_.electronics_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::com::cps2004::Electronics& Camera::_internal_electronics() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::cps2004::Electronics* p = _impl_.electronics_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::cps2004::Electronics&>(::com::cps2004::_Electronics_default_instance_);
}
inline const ::com::cps2004::Electronics& Camera::electronics() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Camera.electronics)
  return _internal_electronics();
}
inline void Camera::unsafe_arena_set_allocated_electronics(::com::cps2004::Electronics* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.electronics_);
  }
  _impl_.electronics_ = reinterpret_cast<::com::cps2004::Electronics*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.cps2004.Camera.electronics)
}
inline ::com::cps2004::Electronics* Camera::release_electronics() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::cps2004::Electronics* released = _impl_.electronics_;
  _impl_.electronics_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::cps2004::Electronics* Camera::unsafe_arena_release_electronics() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.cps2004.Camera.electronics)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::cps2004::Electronics* temp = _impl_.electronics_;
  _impl_.electronics_ = nullptr;
  return temp;
}
inline ::com::cps2004::Electronics* Camera::_internal_mutable_electronics() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.electronics_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::cps2004::Electronics>(GetArena());
    _impl_.electronics_ = reinterpret_cast<::com::cps2004::Electronics*>(p);
  }
  return _impl_.electronics_;
}
inline ::com::cps2004::Electronics* Camera::mutable_electronics() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::cps2004::Electronics* _msg = _internal_mutable_electronics();
  // @@protoc_insertion_point(field_mutable:com.cps2004.Camera.electronics)
  return _msg;
}
inline void Camera::set_allocated_electronics(::com::cps2004::Electronics* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::cps2004::Electronics*>(_impl_.electronics_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::cps2004::Electronics*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.electronics_ = reinterpret_cast<::com::cps2004::Electronics*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.cps2004.Camera.electronics)
}

// double megaPixels = 2;
inline void Camera::clear_megapixels() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.megapixels_ = 0;
}
inline double Camera::megapixels() const {
  // @@protoc_insertion_point(field_get:com.cps2004.Camera.megaPixels)
  return _internal_megapixels();
}
inline void Camera::set_megapixels(double value) {
  _internal_set_megapixels(value);
  // @@protoc_insertion_point(field_set:com.cps2004.Camera.megaPixels)
}
inline double Camera::_internal_megapixels() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.megapixels_;
}
inline void Camera::_internal_set_megapixels(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.megapixels_ = value;
}

// int32 zoom = 3;
inline void Camera::clear_zoom() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.zoom_ = 0;
}
inline ::int32_t Camera::zoom() const {
  // @@protoc_insertion_point(field_get:com.cps2004.Camera.zoom)
  return _internal_zoom();
}
inline void Camera::set_zoom(::int32_t value) {
  _internal_set_zoom(value);
  // @@protoc_insertion_point(field_set:com.cps2004.Camera.zoom)
}
inline ::int32_t Camera::_internal_zoom() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.zoom_;
}
inline void Camera::_internal_set_zoom(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.zoom_ = value;
}

// bool wirelessConnectivity = 4;
inline void Camera::clear_wirelessconnectivity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.wirelessconnectivity_ = false;
}
inline bool Camera::wirelessconnectivity() const {
  // @@protoc_insertion_point(field_get:com.cps2004.Camera.wirelessConnectivity)
  return _internal_wirelessconnectivity();
}
inline void Camera::set_wirelessconnectivity(bool value) {
  _internal_set_wirelessconnectivity(value);
  // @@protoc_insertion_point(field_set:com.cps2004.Camera.wirelessConnectivity)
}
inline bool Camera::_internal_wirelessconnectivity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.wirelessconnectivity_;
}
inline void Camera::_internal_set_wirelessconnectivity(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.wirelessconnectivity_ = value;
}

// -------------------------------------------------------------------

// Laptop

// .com.cps2004.Electronics electronics = 1;
inline bool Laptop::has_electronics() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.electronics_ != nullptr);
  return value;
}
inline void Laptop::clear_electronics() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.electronics_ != nullptr) _impl_.electronics_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::com::cps2004::Electronics& Laptop::_internal_electronics() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::cps2004::Electronics* p = _impl_.electronics_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::cps2004::Electronics&>(::com::cps2004::_Electronics_default_instance_);
}
inline const ::com::cps2004::Electronics& Laptop::electronics() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Laptop.electronics)
  return _internal_electronics();
}
inline void Laptop::unsafe_arena_set_allocated_electronics(::com::cps2004::Electronics* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.electronics_);
  }
  _impl_.electronics_ = reinterpret_cast<::com::cps2004::Electronics*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.cps2004.Laptop.electronics)
}
inline ::com::cps2004::Electronics* Laptop::release_electronics() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::cps2004::Electronics* released = _impl_.electronics_;
  _impl_.electronics_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::cps2004::Electronics* Laptop::unsafe_arena_release_electronics() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.cps2004.Laptop.electronics)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::cps2004::Electronics* temp = _impl_.electronics_;
  _impl_.electronics_ = nullptr;
  return temp;
}
inline ::com::cps2004::Electronics* Laptop::_internal_mutable_electronics() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.electronics_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::cps2004::Electronics>(GetArena());
    _impl_.electronics_ = reinterpret_cast<::com::cps2004::Electronics*>(p);
  }
  return _impl_.electronics_;
}
inline ::com::cps2004::Electronics* Laptop::mutable_electronics() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::cps2004::Electronics* _msg = _internal_mutable_electronics();
  // @@protoc_insertion_point(field_mutable:com.cps2004.Laptop.electronics)
  return _msg;
}
inline void Laptop::set_allocated_electronics(::com::cps2004::Electronics* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::cps2004::Electronics*>(_impl_.electronics_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::cps2004::Electronics*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.electronics_ = reinterpret_cast<::com::cps2004::Electronics*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.cps2004.Laptop.electronics)
}

// double screenSize = 2;
inline void Laptop::clear_screensize() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.screensize_ = 0;
}
inline double Laptop::screensize() const {
  // @@protoc_insertion_point(field_get:com.cps2004.Laptop.screenSize)
  return _internal_screensize();
}
inline void Laptop::set_screensize(double value) {
  _internal_set_screensize(value);
  // @@protoc_insertion_point(field_set:com.cps2004.Laptop.screenSize)
}
inline double Laptop::_internal_screensize() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.screensize_;
}
inline void Laptop::_internal_set_screensize(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.screensize_ = value;
}

// string operatingSystem = 3;
inline void Laptop::clear_operatingsystem() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.operatingsystem_.ClearToEmpty();
}
inline const std::string& Laptop::operatingsystem() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Laptop.operatingSystem)
  return _internal_operatingsystem();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Laptop::set_operatingsystem(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.operatingsystem_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:com.cps2004.Laptop.operatingSystem)
}
inline std::string* Laptop::mutable_operatingsystem() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_operatingsystem();
  // @@protoc_insertion_point(field_mutable:com.cps2004.Laptop.operatingSystem)
  return _s;
}
inline const std::string& Laptop::_internal_operatingsystem() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.operatingsystem_.Get();
}
inline void Laptop::_internal_set_operatingsystem(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.operatingsystem_.Set(value, GetArena());
}
inline std::string* Laptop::_internal_mutable_operatingsystem() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.operatingsystem_.Mutable( GetArena());
}
inline std::string* Laptop::release_operatingsystem() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.cps2004.Laptop.operatingSystem)
  return _impl_.operatingsystem_.Release();
}
inline void Laptop::set_allocated_operatingsystem(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.operatingsystem_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.operatingsystem_.IsDefault()) {
          _impl_.operatingsystem_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.cps2004.Laptop.operatingSystem)
}

// int32 ram = 4;
inline void Laptop::clear_ram() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ram_ = 0;
}
inline ::int32_t Laptop::ram() const {
  // @@protoc_insertion_point(field_get:com.cps2004.Laptop.ram)
  return _internal_ram();
}
inline void Laptop::set_ram(::int32_t value) {
  _internal_set_ram(value);
  // @@protoc_insertion_point(field_set:com.cps2004.Laptop.ram)
}
inline ::int32_t Laptop::_internal_ram() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ram_;
}
inline void Laptop::_internal_set_ram(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ram_ = value;
}

// -------------------------------------------------------------------

// Food

// .com.cps2004.Fruit fruit = 1;
inline bool Food::has_fruit() const {
  return food_type_case() == kFruit;
}
inline bool Food::_internal_has_fruit() const {
  return food_type_case() == kFruit;
}
inline void Food::set_has_fruit() {
  _impl_._oneof_case_[0] = kFruit;
}
inline void Food::clear_fruit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (food_type_case() == kFruit) {
    if (GetArena() == nullptr) {
      delete _impl_.food_type_.fruit_;
    }
    clear_has_food_type();
  }
}
inline ::com::cps2004::Fruit* Food::release_fruit() {
  // @@protoc_insertion_point(field_release:com.cps2004.Food.fruit)
  if (food_type_case() == kFruit) {
    clear_has_food_type();
    auto* temp = _impl_.food_type_.fruit_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.food_type_.fruit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::com::cps2004::Fruit& Food::_internal_fruit() const {
  return food_type_case() == kFruit ? *_impl_.food_type_.fruit_ : reinterpret_cast<::com::cps2004::Fruit&>(::com::cps2004::_Fruit_default_instance_);
}
inline const ::com::cps2004::Fruit& Food::fruit() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Food.fruit)
  return _internal_fruit();
}
inline ::com::cps2004::Fruit* Food::unsafe_arena_release_fruit() {
  // @@protoc_insertion_point(field_unsafe_arena_release:com.cps2004.Food.fruit)
  if (food_type_case() == kFruit) {
    clear_has_food_type();
    auto* temp = _impl_.food_type_.fruit_;
    _impl_.food_type_.fruit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Food::unsafe_arena_set_allocated_fruit(::com::cps2004::Fruit* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_food_type();
  if (value) {
    set_has_fruit();
    _impl_.food_type_.fruit_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.cps2004.Food.fruit)
}
inline ::com::cps2004::Fruit* Food::_internal_mutable_fruit() {
  if (food_type_case() != kFruit) {
    clear_food_type();
    set_has_fruit();
    _impl_.food_type_.fruit_ = CreateMaybeMessage<::com::cps2004::Fruit>(GetArena());
  }
  return _impl_.food_type_.fruit_;
}
inline ::com::cps2004::Fruit* Food::mutable_fruit() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::cps2004::Fruit* _msg = _internal_mutable_fruit();
  // @@protoc_insertion_point(field_mutable:com.cps2004.Food.fruit)
  return _msg;
}

// .com.cps2004.PremadeLunch premadeLunch = 2;
inline bool Food::has_premadelunch() const {
  return food_type_case() == kPremadeLunch;
}
inline bool Food::_internal_has_premadelunch() const {
  return food_type_case() == kPremadeLunch;
}
inline void Food::set_has_premadelunch() {
  _impl_._oneof_case_[0] = kPremadeLunch;
}
inline void Food::clear_premadelunch() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (food_type_case() == kPremadeLunch) {
    if (GetArena() == nullptr) {
      delete _impl_.food_type_.premadelunch_;
    }
    clear_has_food_type();
  }
}
inline ::com::cps2004::PremadeLunch* Food::release_premadelunch() {
  // @@protoc_insertion_point(field_release:com.cps2004.Food.premadeLunch)
  if (food_type_case() == kPremadeLunch) {
    clear_has_food_type();
    auto* temp = _impl_.food_type_.premadelunch_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.food_type_.premadelunch_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::com::cps2004::PremadeLunch& Food::_internal_premadelunch() const {
  return food_type_case() == kPremadeLunch ? *_impl_.food_type_.premadelunch_ : reinterpret_cast<::com::cps2004::PremadeLunch&>(::com::cps2004::_PremadeLunch_default_instance_);
}
inline const ::com::cps2004::PremadeLunch& Food::premadelunch() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Food.premadeLunch)
  return _internal_premadelunch();
}
inline ::com::cps2004::PremadeLunch* Food::unsafe_arena_release_premadelunch() {
  // @@protoc_insertion_point(field_unsafe_arena_release:com.cps2004.Food.premadeLunch)
  if (food_type_case() == kPremadeLunch) {
    clear_has_food_type();
    auto* temp = _impl_.food_type_.premadelunch_;
    _impl_.food_type_.premadelunch_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Food::unsafe_arena_set_allocated_premadelunch(::com::cps2004::PremadeLunch* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_food_type();
  if (value) {
    set_has_premadelunch();
    _impl_.food_type_.premadelunch_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.cps2004.Food.premadeLunch)
}
inline ::com::cps2004::PremadeLunch* Food::_internal_mutable_premadelunch() {
  if (food_type_case() != kPremadeLunch) {
    clear_food_type();
    set_has_premadelunch();
    _impl_.food_type_.premadelunch_ = CreateMaybeMessage<::com::cps2004::PremadeLunch>(GetArena());
  }
  return _impl_.food_type_.premadelunch_;
}
inline ::com::cps2004::PremadeLunch* Food::mutable_premadelunch() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::cps2004::PremadeLunch* _msg = _internal_mutable_premadelunch();
  // @@protoc_insertion_point(field_mutable:com.cps2004.Food.premadeLunch)
  return _msg;
}

// .com.cps2004.Product product = 3;
inline bool Food::has_product() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.product_ != nullptr);
  return value;
}
inline void Food::clear_product() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.product_ != nullptr) _impl_.product_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::com::cps2004::Product& Food::_internal_product() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::cps2004::Product* p = _impl_.product_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::cps2004::Product&>(::com::cps2004::_Product_default_instance_);
}
inline const ::com::cps2004::Product& Food::product() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Food.product)
  return _internal_product();
}
inline void Food::unsafe_arena_set_allocated_product(::com::cps2004::Product* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.product_);
  }
  _impl_.product_ = reinterpret_cast<::com::cps2004::Product*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.cps2004.Food.product)
}
inline ::com::cps2004::Product* Food::release_product() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::cps2004::Product* released = _impl_.product_;
  _impl_.product_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::cps2004::Product* Food::unsafe_arena_release_product() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.cps2004.Food.product)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::cps2004::Product* temp = _impl_.product_;
  _impl_.product_ = nullptr;
  return temp;
}
inline ::com::cps2004::Product* Food::_internal_mutable_product() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.product_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::cps2004::Product>(GetArena());
    _impl_.product_ = reinterpret_cast<::com::cps2004::Product*>(p);
  }
  return _impl_.product_;
}
inline ::com::cps2004::Product* Food::mutable_product() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::cps2004::Product* _msg = _internal_mutable_product();
  // @@protoc_insertion_point(field_mutable:com.cps2004.Food.product)
  return _msg;
}
inline void Food::set_allocated_product(::com::cps2004::Product* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::cps2004::Product*>(_impl_.product_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::cps2004::Product*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.product_ = reinterpret_cast<::com::cps2004::Product*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.cps2004.Food.product)
}

// double weight = 4;
inline void Food::clear_weight() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.weight_ = 0;
}
inline double Food::weight() const {
  // @@protoc_insertion_point(field_get:com.cps2004.Food.weight)
  return _internal_weight();
}
inline void Food::set_weight(double value) {
  _internal_set_weight(value);
  // @@protoc_insertion_point(field_set:com.cps2004.Food.weight)
}
inline double Food::_internal_weight() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.weight_;
}
inline void Food::_internal_set_weight(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.weight_ = value;
}

// string expirationDate = 5;
inline void Food::clear_expirationdate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.expirationdate_.ClearToEmpty();
}
inline const std::string& Food::expirationdate() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Food.expirationDate)
  return _internal_expirationdate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Food::set_expirationdate(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.expirationdate_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:com.cps2004.Food.expirationDate)
}
inline std::string* Food::mutable_expirationdate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_expirationdate();
  // @@protoc_insertion_point(field_mutable:com.cps2004.Food.expirationDate)
  return _s;
}
inline const std::string& Food::_internal_expirationdate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.expirationdate_.Get();
}
inline void Food::_internal_set_expirationdate(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.expirationdate_.Set(value, GetArena());
}
inline std::string* Food::_internal_mutable_expirationdate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.expirationdate_.Mutable( GetArena());
}
inline std::string* Food::release_expirationdate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.cps2004.Food.expirationDate)
  return _impl_.expirationdate_.Release();
}
inline void Food::set_allocated_expirationdate(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.expirationdate_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.expirationdate_.IsDefault()) {
          _impl_.expirationdate_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.cps2004.Food.expirationDate)
}

inline bool Food::has_food_type() const {
  return food_type_case() != FOOD_TYPE_NOT_SET;
}
inline void Food::clear_has_food_type() {
  _impl_._oneof_case_[0] = FOOD_TYPE_NOT_SET;
}
inline Food::FoodTypeCase Food::food_type_case() const {
  return Food::FoodTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Fruit

// .com.cps2004.Food food = 1;
inline bool Fruit::has_food() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.food_ != nullptr);
  return value;
}
inline void Fruit::clear_food() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.food_ != nullptr) _impl_.food_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::com::cps2004::Food& Fruit::_internal_food() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::cps2004::Food* p = _impl_.food_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::cps2004::Food&>(::com::cps2004::_Food_default_instance_);
}
inline const ::com::cps2004::Food& Fruit::food() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Fruit.food)
  return _internal_food();
}
inline void Fruit::unsafe_arena_set_allocated_food(::com::cps2004::Food* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.food_);
  }
  _impl_.food_ = reinterpret_cast<::com::cps2004::Food*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.cps2004.Fruit.food)
}
inline ::com::cps2004::Food* Fruit::release_food() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::cps2004::Food* released = _impl_.food_;
  _impl_.food_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::cps2004::Food* Fruit::unsafe_arena_release_food() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.cps2004.Fruit.food)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::cps2004::Food* temp = _impl_.food_;
  _impl_.food_ = nullptr;
  return temp;
}
inline ::com::cps2004::Food* Fruit::_internal_mutable_food() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.food_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::cps2004::Food>(GetArena());
    _impl_.food_ = reinterpret_cast<::com::cps2004::Food*>(p);
  }
  return _impl_.food_;
}
inline ::com::cps2004::Food* Fruit::mutable_food() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::cps2004::Food* _msg = _internal_mutable_food();
  // @@protoc_insertion_point(field_mutable:com.cps2004.Fruit.food)
  return _msg;
}
inline void Fruit::set_allocated_food(::com::cps2004::Food* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::cps2004::Food*>(_impl_.food_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::cps2004::Food*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.food_ = reinterpret_cast<::com::cps2004::Food*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.cps2004.Fruit.food)
}

// string countryOfOrigin = 2;
inline void Fruit::clear_countryoforigin() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.countryoforigin_.ClearToEmpty();
}
inline const std::string& Fruit::countryoforigin() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Fruit.countryOfOrigin)
  return _internal_countryoforigin();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Fruit::set_countryoforigin(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.countryoforigin_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:com.cps2004.Fruit.countryOfOrigin)
}
inline std::string* Fruit::mutable_countryoforigin() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_countryoforigin();
  // @@protoc_insertion_point(field_mutable:com.cps2004.Fruit.countryOfOrigin)
  return _s;
}
inline const std::string& Fruit::_internal_countryoforigin() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.countryoforigin_.Get();
}
inline void Fruit::_internal_set_countryoforigin(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.countryoforigin_.Set(value, GetArena());
}
inline std::string* Fruit::_internal_mutable_countryoforigin() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.countryoforigin_.Mutable( GetArena());
}
inline std::string* Fruit::release_countryoforigin() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.cps2004.Fruit.countryOfOrigin)
  return _impl_.countryoforigin_.Release();
}
inline void Fruit::set_allocated_countryoforigin(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.countryoforigin_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.countryoforigin_.IsDefault()) {
          _impl_.countryoforigin_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.cps2004.Fruit.countryOfOrigin)
}

// string type = 3;
inline void Fruit::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_.ClearToEmpty();
}
inline const std::string& Fruit::type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Fruit.type)
  return _internal_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Fruit::set_type(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:com.cps2004.Fruit.type)
}
inline std::string* Fruit::mutable_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:com.cps2004.Fruit.type)
  return _s;
}
inline const std::string& Fruit::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.type_.Get();
}
inline void Fruit::_internal_set_type(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_.Set(value, GetArena());
}
inline std::string* Fruit::_internal_mutable_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.type_.Mutable( GetArena());
}
inline std::string* Fruit::release_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.cps2004.Fruit.type)
  return _impl_.type_.Release();
}
inline void Fruit::set_allocated_type(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.type_.IsDefault()) {
          _impl_.type_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.cps2004.Fruit.type)
}

// bool organic = 4;
inline void Fruit::clear_organic() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.organic_ = false;
}
inline bool Fruit::organic() const {
  // @@protoc_insertion_point(field_get:com.cps2004.Fruit.organic)
  return _internal_organic();
}
inline void Fruit::set_organic(bool value) {
  _internal_set_organic(value);
  // @@protoc_insertion_point(field_set:com.cps2004.Fruit.organic)
}
inline bool Fruit::_internal_organic() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.organic_;
}
inline void Fruit::_internal_set_organic(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.organic_ = value;
}

// -------------------------------------------------------------------

// PremadeLunch

// .com.cps2004.Food food = 1;
inline bool PremadeLunch::has_food() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.food_ != nullptr);
  return value;
}
inline void PremadeLunch::clear_food() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.food_ != nullptr) _impl_.food_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::com::cps2004::Food& PremadeLunch::_internal_food() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::cps2004::Food* p = _impl_.food_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::cps2004::Food&>(::com::cps2004::_Food_default_instance_);
}
inline const ::com::cps2004::Food& PremadeLunch::food() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.PremadeLunch.food)
  return _internal_food();
}
inline void PremadeLunch::unsafe_arena_set_allocated_food(::com::cps2004::Food* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.food_);
  }
  _impl_.food_ = reinterpret_cast<::com::cps2004::Food*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.cps2004.PremadeLunch.food)
}
inline ::com::cps2004::Food* PremadeLunch::release_food() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::cps2004::Food* released = _impl_.food_;
  _impl_.food_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::cps2004::Food* PremadeLunch::unsafe_arena_release_food() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.cps2004.PremadeLunch.food)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::cps2004::Food* temp = _impl_.food_;
  _impl_.food_ = nullptr;
  return temp;
}
inline ::com::cps2004::Food* PremadeLunch::_internal_mutable_food() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.food_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::cps2004::Food>(GetArena());
    _impl_.food_ = reinterpret_cast<::com::cps2004::Food*>(p);
  }
  return _impl_.food_;
}
inline ::com::cps2004::Food* PremadeLunch::mutable_food() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::cps2004::Food* _msg = _internal_mutable_food();
  // @@protoc_insertion_point(field_mutable:com.cps2004.PremadeLunch.food)
  return _msg;
}
inline void PremadeLunch::set_allocated_food(::com::cps2004::Food* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::cps2004::Food*>(_impl_.food_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::cps2004::Food*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.food_ = reinterpret_cast<::com::cps2004::Food*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.cps2004.PremadeLunch.food)
}

// bool perishable = 2;
inline void PremadeLunch::clear_perishable() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.perishable_ = false;
}
inline bool PremadeLunch::perishable() const {
  // @@protoc_insertion_point(field_get:com.cps2004.PremadeLunch.perishable)
  return _internal_perishable();
}
inline void PremadeLunch::set_perishable(bool value) {
  _internal_set_perishable(value);
  // @@protoc_insertion_point(field_set:com.cps2004.PremadeLunch.perishable)
}
inline bool PremadeLunch::_internal_perishable() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.perishable_;
}
inline void PremadeLunch::_internal_set_perishable(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.perishable_ = value;
}

// string ingredients = 3;
inline void PremadeLunch::clear_ingredients() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ingredients_.ClearToEmpty();
}
inline const std::string& PremadeLunch::ingredients() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.PremadeLunch.ingredients)
  return _internal_ingredients();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PremadeLunch::set_ingredients(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ingredients_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:com.cps2004.PremadeLunch.ingredients)
}
inline std::string* PremadeLunch::mutable_ingredients() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ingredients();
  // @@protoc_insertion_point(field_mutable:com.cps2004.PremadeLunch.ingredients)
  return _s;
}
inline const std::string& PremadeLunch::_internal_ingredients() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ingredients_.Get();
}
inline void PremadeLunch::_internal_set_ingredients(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ingredients_.Set(value, GetArena());
}
inline std::string* PremadeLunch::_internal_mutable_ingredients() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.ingredients_.Mutable( GetArena());
}
inline std::string* PremadeLunch::release_ingredients() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.cps2004.PremadeLunch.ingredients)
  return _impl_.ingredients_.Release();
}
inline void PremadeLunch::set_allocated_ingredients(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ingredients_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ingredients_.IsDefault()) {
          _impl_.ingredients_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.cps2004.PremadeLunch.ingredients)
}

// string allergens = 4;
inline void PremadeLunch::clear_allergens() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.allergens_.ClearToEmpty();
}
inline const std::string& PremadeLunch::allergens() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.PremadeLunch.allergens)
  return _internal_allergens();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PremadeLunch::set_allergens(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.allergens_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:com.cps2004.PremadeLunch.allergens)
}
inline std::string* PremadeLunch::mutable_allergens() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_allergens();
  // @@protoc_insertion_point(field_mutable:com.cps2004.PremadeLunch.allergens)
  return _s;
}
inline const std::string& PremadeLunch::_internal_allergens() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.allergens_.Get();
}
inline void PremadeLunch::_internal_set_allergens(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.allergens_.Set(value, GetArena());
}
inline std::string* PremadeLunch::_internal_mutable_allergens() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.allergens_.Mutable( GetArena());
}
inline std::string* PremadeLunch::release_allergens() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.cps2004.PremadeLunch.allergens)
  return _impl_.allergens_.Release();
}
inline void PremadeLunch::set_allocated_allergens(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.allergens_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.allergens_.IsDefault()) {
          _impl_.allergens_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.cps2004.PremadeLunch.allergens)
}

// -------------------------------------------------------------------

// Clothes

// .com.cps2004.Pants pants = 1;
inline bool Clothes::has_pants() const {
  return clothes_type_case() == kPants;
}
inline bool Clothes::_internal_has_pants() const {
  return clothes_type_case() == kPants;
}
inline void Clothes::set_has_pants() {
  _impl_._oneof_case_[0] = kPants;
}
inline void Clothes::clear_pants() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (clothes_type_case() == kPants) {
    if (GetArena() == nullptr) {
      delete _impl_.clothes_type_.pants_;
    }
    clear_has_clothes_type();
  }
}
inline ::com::cps2004::Pants* Clothes::release_pants() {
  // @@protoc_insertion_point(field_release:com.cps2004.Clothes.pants)
  if (clothes_type_case() == kPants) {
    clear_has_clothes_type();
    auto* temp = _impl_.clothes_type_.pants_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.clothes_type_.pants_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::com::cps2004::Pants& Clothes::_internal_pants() const {
  return clothes_type_case() == kPants ? *_impl_.clothes_type_.pants_ : reinterpret_cast<::com::cps2004::Pants&>(::com::cps2004::_Pants_default_instance_);
}
inline const ::com::cps2004::Pants& Clothes::pants() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Clothes.pants)
  return _internal_pants();
}
inline ::com::cps2004::Pants* Clothes::unsafe_arena_release_pants() {
  // @@protoc_insertion_point(field_unsafe_arena_release:com.cps2004.Clothes.pants)
  if (clothes_type_case() == kPants) {
    clear_has_clothes_type();
    auto* temp = _impl_.clothes_type_.pants_;
    _impl_.clothes_type_.pants_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Clothes::unsafe_arena_set_allocated_pants(::com::cps2004::Pants* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_clothes_type();
  if (value) {
    set_has_pants();
    _impl_.clothes_type_.pants_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.cps2004.Clothes.pants)
}
inline ::com::cps2004::Pants* Clothes::_internal_mutable_pants() {
  if (clothes_type_case() != kPants) {
    clear_clothes_type();
    set_has_pants();
    _impl_.clothes_type_.pants_ = CreateMaybeMessage<::com::cps2004::Pants>(GetArena());
  }
  return _impl_.clothes_type_.pants_;
}
inline ::com::cps2004::Pants* Clothes::mutable_pants() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::cps2004::Pants* _msg = _internal_mutable_pants();
  // @@protoc_insertion_point(field_mutable:com.cps2004.Clothes.pants)
  return _msg;
}

// .com.cps2004.TShirt tShirt = 2;
inline bool Clothes::has_tshirt() const {
  return clothes_type_case() == kTShirt;
}
inline bool Clothes::_internal_has_tshirt() const {
  return clothes_type_case() == kTShirt;
}
inline void Clothes::set_has_tshirt() {
  _impl_._oneof_case_[0] = kTShirt;
}
inline void Clothes::clear_tshirt() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (clothes_type_case() == kTShirt) {
    if (GetArena() == nullptr) {
      delete _impl_.clothes_type_.tshirt_;
    }
    clear_has_clothes_type();
  }
}
inline ::com::cps2004::TShirt* Clothes::release_tshirt() {
  // @@protoc_insertion_point(field_release:com.cps2004.Clothes.tShirt)
  if (clothes_type_case() == kTShirt) {
    clear_has_clothes_type();
    auto* temp = _impl_.clothes_type_.tshirt_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.clothes_type_.tshirt_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::com::cps2004::TShirt& Clothes::_internal_tshirt() const {
  return clothes_type_case() == kTShirt ? *_impl_.clothes_type_.tshirt_ : reinterpret_cast<::com::cps2004::TShirt&>(::com::cps2004::_TShirt_default_instance_);
}
inline const ::com::cps2004::TShirt& Clothes::tshirt() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Clothes.tShirt)
  return _internal_tshirt();
}
inline ::com::cps2004::TShirt* Clothes::unsafe_arena_release_tshirt() {
  // @@protoc_insertion_point(field_unsafe_arena_release:com.cps2004.Clothes.tShirt)
  if (clothes_type_case() == kTShirt) {
    clear_has_clothes_type();
    auto* temp = _impl_.clothes_type_.tshirt_;
    _impl_.clothes_type_.tshirt_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Clothes::unsafe_arena_set_allocated_tshirt(::com::cps2004::TShirt* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_clothes_type();
  if (value) {
    set_has_tshirt();
    _impl_.clothes_type_.tshirt_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.cps2004.Clothes.tShirt)
}
inline ::com::cps2004::TShirt* Clothes::_internal_mutable_tshirt() {
  if (clothes_type_case() != kTShirt) {
    clear_clothes_type();
    set_has_tshirt();
    _impl_.clothes_type_.tshirt_ = CreateMaybeMessage<::com::cps2004::TShirt>(GetArena());
  }
  return _impl_.clothes_type_.tshirt_;
}
inline ::com::cps2004::TShirt* Clothes::mutable_tshirt() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::cps2004::TShirt* _msg = _internal_mutable_tshirt();
  // @@protoc_insertion_point(field_mutable:com.cps2004.Clothes.tShirt)
  return _msg;
}

// .com.cps2004.Product product = 3;
inline bool Clothes::has_product() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.product_ != nullptr);
  return value;
}
inline void Clothes::clear_product() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.product_ != nullptr) _impl_.product_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::com::cps2004::Product& Clothes::_internal_product() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::cps2004::Product* p = _impl_.product_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::cps2004::Product&>(::com::cps2004::_Product_default_instance_);
}
inline const ::com::cps2004::Product& Clothes::product() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Clothes.product)
  return _internal_product();
}
inline void Clothes::unsafe_arena_set_allocated_product(::com::cps2004::Product* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.product_);
  }
  _impl_.product_ = reinterpret_cast<::com::cps2004::Product*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.cps2004.Clothes.product)
}
inline ::com::cps2004::Product* Clothes::release_product() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::cps2004::Product* released = _impl_.product_;
  _impl_.product_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::cps2004::Product* Clothes::unsafe_arena_release_product() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.cps2004.Clothes.product)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::cps2004::Product* temp = _impl_.product_;
  _impl_.product_ = nullptr;
  return temp;
}
inline ::com::cps2004::Product* Clothes::_internal_mutable_product() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.product_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::cps2004::Product>(GetArena());
    _impl_.product_ = reinterpret_cast<::com::cps2004::Product*>(p);
  }
  return _impl_.product_;
}
inline ::com::cps2004::Product* Clothes::mutable_product() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::cps2004::Product* _msg = _internal_mutable_product();
  // @@protoc_insertion_point(field_mutable:com.cps2004.Clothes.product)
  return _msg;
}
inline void Clothes::set_allocated_product(::com::cps2004::Product* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::cps2004::Product*>(_impl_.product_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::cps2004::Product*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.product_ = reinterpret_cast<::com::cps2004::Product*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.cps2004.Clothes.product)
}

// string size = 4;
inline void Clothes::clear_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.size_.ClearToEmpty();
}
inline const std::string& Clothes::size() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Clothes.size)
  return _internal_size();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Clothes::set_size(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.size_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:com.cps2004.Clothes.size)
}
inline std::string* Clothes::mutable_size() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_size();
  // @@protoc_insertion_point(field_mutable:com.cps2004.Clothes.size)
  return _s;
}
inline const std::string& Clothes::_internal_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.size_.Get();
}
inline void Clothes::_internal_set_size(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.size_.Set(value, GetArena());
}
inline std::string* Clothes::_internal_mutable_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.size_.Mutable( GetArena());
}
inline std::string* Clothes::release_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.cps2004.Clothes.size)
  return _impl_.size_.Release();
}
inline void Clothes::set_allocated_size(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.size_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.size_.IsDefault()) {
          _impl_.size_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.cps2004.Clothes.size)
}

// string brand = 5;
inline void Clothes::clear_brand() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.brand_.ClearToEmpty();
}
inline const std::string& Clothes::brand() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Clothes.brand)
  return _internal_brand();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Clothes::set_brand(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.brand_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:com.cps2004.Clothes.brand)
}
inline std::string* Clothes::mutable_brand() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_brand();
  // @@protoc_insertion_point(field_mutable:com.cps2004.Clothes.brand)
  return _s;
}
inline const std::string& Clothes::_internal_brand() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.brand_.Get();
}
inline void Clothes::_internal_set_brand(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.brand_.Set(value, GetArena());
}
inline std::string* Clothes::_internal_mutable_brand() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.brand_.Mutable( GetArena());
}
inline std::string* Clothes::release_brand() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.cps2004.Clothes.brand)
  return _impl_.brand_.Release();
}
inline void Clothes::set_allocated_brand(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.brand_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.brand_.IsDefault()) {
          _impl_.brand_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.cps2004.Clothes.brand)
}

// string material = 6;
inline void Clothes::clear_material() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.material_.ClearToEmpty();
}
inline const std::string& Clothes::material() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Clothes.material)
  return _internal_material();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Clothes::set_material(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.material_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:com.cps2004.Clothes.material)
}
inline std::string* Clothes::mutable_material() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_material();
  // @@protoc_insertion_point(field_mutable:com.cps2004.Clothes.material)
  return _s;
}
inline const std::string& Clothes::_internal_material() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.material_.Get();
}
inline void Clothes::_internal_set_material(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.material_.Set(value, GetArena());
}
inline std::string* Clothes::_internal_mutable_material() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.material_.Mutable( GetArena());
}
inline std::string* Clothes::release_material() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.cps2004.Clothes.material)
  return _impl_.material_.Release();
}
inline void Clothes::set_allocated_material(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.material_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.material_.IsDefault()) {
          _impl_.material_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.cps2004.Clothes.material)
}

inline bool Clothes::has_clothes_type() const {
  return clothes_type_case() != CLOTHES_TYPE_NOT_SET;
}
inline void Clothes::clear_has_clothes_type() {
  _impl_._oneof_case_[0] = CLOTHES_TYPE_NOT_SET;
}
inline Clothes::ClothesTypeCase Clothes::clothes_type_case() const {
  return Clothes::ClothesTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Pants

// .com.cps2004.Clothes clothes = 1;
inline bool Pants::has_clothes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.clothes_ != nullptr);
  return value;
}
inline void Pants::clear_clothes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.clothes_ != nullptr) _impl_.clothes_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::com::cps2004::Clothes& Pants::_internal_clothes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::cps2004::Clothes* p = _impl_.clothes_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::cps2004::Clothes&>(::com::cps2004::_Clothes_default_instance_);
}
inline const ::com::cps2004::Clothes& Pants::clothes() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Pants.clothes)
  return _internal_clothes();
}
inline void Pants::unsafe_arena_set_allocated_clothes(::com::cps2004::Clothes* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.clothes_);
  }
  _impl_.clothes_ = reinterpret_cast<::com::cps2004::Clothes*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.cps2004.Pants.clothes)
}
inline ::com::cps2004::Clothes* Pants::release_clothes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::cps2004::Clothes* released = _impl_.clothes_;
  _impl_.clothes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::cps2004::Clothes* Pants::unsafe_arena_release_clothes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.cps2004.Pants.clothes)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::cps2004::Clothes* temp = _impl_.clothes_;
  _impl_.clothes_ = nullptr;
  return temp;
}
inline ::com::cps2004::Clothes* Pants::_internal_mutable_clothes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.clothes_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::cps2004::Clothes>(GetArena());
    _impl_.clothes_ = reinterpret_cast<::com::cps2004::Clothes*>(p);
  }
  return _impl_.clothes_;
}
inline ::com::cps2004::Clothes* Pants::mutable_clothes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::cps2004::Clothes* _msg = _internal_mutable_clothes();
  // @@protoc_insertion_point(field_mutable:com.cps2004.Pants.clothes)
  return _msg;
}
inline void Pants::set_allocated_clothes(::com::cps2004::Clothes* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::cps2004::Clothes*>(_impl_.clothes_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::cps2004::Clothes*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.clothes_ = reinterpret_cast<::com::cps2004::Clothes*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.cps2004.Pants.clothes)
}

// double inseam = 2;
inline void Pants::clear_inseam() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.inseam_ = 0;
}
inline double Pants::inseam() const {
  // @@protoc_insertion_point(field_get:com.cps2004.Pants.inseam)
  return _internal_inseam();
}
inline void Pants::set_inseam(double value) {
  _internal_set_inseam(value);
  // @@protoc_insertion_point(field_set:com.cps2004.Pants.inseam)
}
inline double Pants::_internal_inseam() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.inseam_;
}
inline void Pants::_internal_set_inseam(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.inseam_ = value;
}

// double waist = 3;
inline void Pants::clear_waist() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.waist_ = 0;
}
inline double Pants::waist() const {
  // @@protoc_insertion_point(field_get:com.cps2004.Pants.waist)
  return _internal_waist();
}
inline void Pants::set_waist(double value) {
  _internal_set_waist(value);
  // @@protoc_insertion_point(field_set:com.cps2004.Pants.waist)
}
inline double Pants::_internal_waist() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.waist_;
}
inline void Pants::_internal_set_waist(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.waist_ = value;
}

// -------------------------------------------------------------------

// TShirt

// .com.cps2004.Clothes clothes = 1;
inline bool TShirt::has_clothes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.clothes_ != nullptr);
  return value;
}
inline void TShirt::clear_clothes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.clothes_ != nullptr) _impl_.clothes_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::com::cps2004::Clothes& TShirt::_internal_clothes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::cps2004::Clothes* p = _impl_.clothes_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::cps2004::Clothes&>(::com::cps2004::_Clothes_default_instance_);
}
inline const ::com::cps2004::Clothes& TShirt::clothes() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.TShirt.clothes)
  return _internal_clothes();
}
inline void TShirt::unsafe_arena_set_allocated_clothes(::com::cps2004::Clothes* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.clothes_);
  }
  _impl_.clothes_ = reinterpret_cast<::com::cps2004::Clothes*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.cps2004.TShirt.clothes)
}
inline ::com::cps2004::Clothes* TShirt::release_clothes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::cps2004::Clothes* released = _impl_.clothes_;
  _impl_.clothes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::cps2004::Clothes* TShirt::unsafe_arena_release_clothes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.cps2004.TShirt.clothes)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::cps2004::Clothes* temp = _impl_.clothes_;
  _impl_.clothes_ = nullptr;
  return temp;
}
inline ::com::cps2004::Clothes* TShirt::_internal_mutable_clothes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.clothes_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::cps2004::Clothes>(GetArena());
    _impl_.clothes_ = reinterpret_cast<::com::cps2004::Clothes*>(p);
  }
  return _impl_.clothes_;
}
inline ::com::cps2004::Clothes* TShirt::mutable_clothes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::cps2004::Clothes* _msg = _internal_mutable_clothes();
  // @@protoc_insertion_point(field_mutable:com.cps2004.TShirt.clothes)
  return _msg;
}
inline void TShirt::set_allocated_clothes(::com::cps2004::Clothes* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::cps2004::Clothes*>(_impl_.clothes_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::cps2004::Clothes*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.clothes_ = reinterpret_cast<::com::cps2004::Clothes*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.cps2004.TShirt.clothes)
}

// string collar = 2;
inline void TShirt::clear_collar() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.collar_.ClearToEmpty();
}
inline const std::string& TShirt::collar() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.TShirt.collar)
  return _internal_collar();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TShirt::set_collar(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.collar_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:com.cps2004.TShirt.collar)
}
inline std::string* TShirt::mutable_collar() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_collar();
  // @@protoc_insertion_point(field_mutable:com.cps2004.TShirt.collar)
  return _s;
}
inline const std::string& TShirt::_internal_collar() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.collar_.Get();
}
inline void TShirt::_internal_set_collar(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.collar_.Set(value, GetArena());
}
inline std::string* TShirt::_internal_mutable_collar() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.collar_.Mutable( GetArena());
}
inline std::string* TShirt::release_collar() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.cps2004.TShirt.collar)
  return _impl_.collar_.Release();
}
inline void TShirt::set_allocated_collar(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.collar_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.collar_.IsDefault()) {
          _impl_.collar_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.cps2004.TShirt.collar)
}

// bool graphics = 3;
inline void TShirt::clear_graphics() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.graphics_ = false;
}
inline bool TShirt::graphics() const {
  // @@protoc_insertion_point(field_get:com.cps2004.TShirt.graphics)
  return _internal_graphics();
}
inline void TShirt::set_graphics(bool value) {
  _internal_set_graphics(value);
  // @@protoc_insertion_point(field_set:com.cps2004.TShirt.graphics)
}
inline bool TShirt::_internal_graphics() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.graphics_;
}
inline void TShirt::_internal_set_graphics(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.graphics_ = value;
}

// -------------------------------------------------------------------

// Furniture

// .com.cps2004.Table table = 1;
inline bool Furniture::has_table() const {
  return furniture_type_case() == kTable;
}
inline bool Furniture::_internal_has_table() const {
  return furniture_type_case() == kTable;
}
inline void Furniture::set_has_table() {
  _impl_._oneof_case_[0] = kTable;
}
inline void Furniture::clear_table() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (furniture_type_case() == kTable) {
    if (GetArena() == nullptr) {
      delete _impl_.furniture_type_.table_;
    }
    clear_has_furniture_type();
  }
}
inline ::com::cps2004::Table* Furniture::release_table() {
  // @@protoc_insertion_point(field_release:com.cps2004.Furniture.table)
  if (furniture_type_case() == kTable) {
    clear_has_furniture_type();
    auto* temp = _impl_.furniture_type_.table_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.furniture_type_.table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::com::cps2004::Table& Furniture::_internal_table() const {
  return furniture_type_case() == kTable ? *_impl_.furniture_type_.table_ : reinterpret_cast<::com::cps2004::Table&>(::com::cps2004::_Table_default_instance_);
}
inline const ::com::cps2004::Table& Furniture::table() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Furniture.table)
  return _internal_table();
}
inline ::com::cps2004::Table* Furniture::unsafe_arena_release_table() {
  // @@protoc_insertion_point(field_unsafe_arena_release:com.cps2004.Furniture.table)
  if (furniture_type_case() == kTable) {
    clear_has_furniture_type();
    auto* temp = _impl_.furniture_type_.table_;
    _impl_.furniture_type_.table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Furniture::unsafe_arena_set_allocated_table(::com::cps2004::Table* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_furniture_type();
  if (value) {
    set_has_table();
    _impl_.furniture_type_.table_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.cps2004.Furniture.table)
}
inline ::com::cps2004::Table* Furniture::_internal_mutable_table() {
  if (furniture_type_case() != kTable) {
    clear_furniture_type();
    set_has_table();
    _impl_.furniture_type_.table_ = CreateMaybeMessage<::com::cps2004::Table>(GetArena());
  }
  return _impl_.furniture_type_.table_;
}
inline ::com::cps2004::Table* Furniture::mutable_table() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::cps2004::Table* _msg = _internal_mutable_table();
  // @@protoc_insertion_point(field_mutable:com.cps2004.Furniture.table)
  return _msg;
}

// .com.cps2004.Chair chair = 2;
inline bool Furniture::has_chair() const {
  return furniture_type_case() == kChair;
}
inline bool Furniture::_internal_has_chair() const {
  return furniture_type_case() == kChair;
}
inline void Furniture::set_has_chair() {
  _impl_._oneof_case_[0] = kChair;
}
inline void Furniture::clear_chair() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (furniture_type_case() == kChair) {
    if (GetArena() == nullptr) {
      delete _impl_.furniture_type_.chair_;
    }
    clear_has_furniture_type();
  }
}
inline ::com::cps2004::Chair* Furniture::release_chair() {
  // @@protoc_insertion_point(field_release:com.cps2004.Furniture.chair)
  if (furniture_type_case() == kChair) {
    clear_has_furniture_type();
    auto* temp = _impl_.furniture_type_.chair_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.furniture_type_.chair_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::com::cps2004::Chair& Furniture::_internal_chair() const {
  return furniture_type_case() == kChair ? *_impl_.furniture_type_.chair_ : reinterpret_cast<::com::cps2004::Chair&>(::com::cps2004::_Chair_default_instance_);
}
inline const ::com::cps2004::Chair& Furniture::chair() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Furniture.chair)
  return _internal_chair();
}
inline ::com::cps2004::Chair* Furniture::unsafe_arena_release_chair() {
  // @@protoc_insertion_point(field_unsafe_arena_release:com.cps2004.Furniture.chair)
  if (furniture_type_case() == kChair) {
    clear_has_furniture_type();
    auto* temp = _impl_.furniture_type_.chair_;
    _impl_.furniture_type_.chair_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Furniture::unsafe_arena_set_allocated_chair(::com::cps2004::Chair* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_furniture_type();
  if (value) {
    set_has_chair();
    _impl_.furniture_type_.chair_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.cps2004.Furniture.chair)
}
inline ::com::cps2004::Chair* Furniture::_internal_mutable_chair() {
  if (furniture_type_case() != kChair) {
    clear_furniture_type();
    set_has_chair();
    _impl_.furniture_type_.chair_ = CreateMaybeMessage<::com::cps2004::Chair>(GetArena());
  }
  return _impl_.furniture_type_.chair_;
}
inline ::com::cps2004::Chair* Furniture::mutable_chair() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::cps2004::Chair* _msg = _internal_mutable_chair();
  // @@protoc_insertion_point(field_mutable:com.cps2004.Furniture.chair)
  return _msg;
}

// .com.cps2004.Product product = 3;
inline bool Furniture::has_product() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.product_ != nullptr);
  return value;
}
inline void Furniture::clear_product() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.product_ != nullptr) _impl_.product_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::com::cps2004::Product& Furniture::_internal_product() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::cps2004::Product* p = _impl_.product_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::cps2004::Product&>(::com::cps2004::_Product_default_instance_);
}
inline const ::com::cps2004::Product& Furniture::product() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Furniture.product)
  return _internal_product();
}
inline void Furniture::unsafe_arena_set_allocated_product(::com::cps2004::Product* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.product_);
  }
  _impl_.product_ = reinterpret_cast<::com::cps2004::Product*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.cps2004.Furniture.product)
}
inline ::com::cps2004::Product* Furniture::release_product() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::cps2004::Product* released = _impl_.product_;
  _impl_.product_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::cps2004::Product* Furniture::unsafe_arena_release_product() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.cps2004.Furniture.product)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::cps2004::Product* temp = _impl_.product_;
  _impl_.product_ = nullptr;
  return temp;
}
inline ::com::cps2004::Product* Furniture::_internal_mutable_product() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.product_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::cps2004::Product>(GetArena());
    _impl_.product_ = reinterpret_cast<::com::cps2004::Product*>(p);
  }
  return _impl_.product_;
}
inline ::com::cps2004::Product* Furniture::mutable_product() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::cps2004::Product* _msg = _internal_mutable_product();
  // @@protoc_insertion_point(field_mutable:com.cps2004.Furniture.product)
  return _msg;
}
inline void Furniture::set_allocated_product(::com::cps2004::Product* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::cps2004::Product*>(_impl_.product_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::cps2004::Product*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.product_ = reinterpret_cast<::com::cps2004::Product*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.cps2004.Furniture.product)
}

// string material = 4;
inline void Furniture::clear_material() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.material_.ClearToEmpty();
}
inline const std::string& Furniture::material() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Furniture.material)
  return _internal_material();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Furniture::set_material(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.material_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:com.cps2004.Furniture.material)
}
inline std::string* Furniture::mutable_material() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_material();
  // @@protoc_insertion_point(field_mutable:com.cps2004.Furniture.material)
  return _s;
}
inline const std::string& Furniture::_internal_material() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.material_.Get();
}
inline void Furniture::_internal_set_material(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.material_.Set(value, GetArena());
}
inline std::string* Furniture::_internal_mutable_material() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.material_.Mutable( GetArena());
}
inline std::string* Furniture::release_material() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.cps2004.Furniture.material)
  return _impl_.material_.Release();
}
inline void Furniture::set_allocated_material(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.material_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.material_.IsDefault()) {
          _impl_.material_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.cps2004.Furniture.material)
}

// string dimensions = 5;
inline void Furniture::clear_dimensions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dimensions_.ClearToEmpty();
}
inline const std::string& Furniture::dimensions() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Furniture.dimensions)
  return _internal_dimensions();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Furniture::set_dimensions(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.dimensions_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:com.cps2004.Furniture.dimensions)
}
inline std::string* Furniture::mutable_dimensions() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_dimensions();
  // @@protoc_insertion_point(field_mutable:com.cps2004.Furniture.dimensions)
  return _s;
}
inline const std::string& Furniture::_internal_dimensions() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dimensions_.Get();
}
inline void Furniture::_internal_set_dimensions(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.dimensions_.Set(value, GetArena());
}
inline std::string* Furniture::_internal_mutable_dimensions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.dimensions_.Mutable( GetArena());
}
inline std::string* Furniture::release_dimensions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.cps2004.Furniture.dimensions)
  return _impl_.dimensions_.Release();
}
inline void Furniture::set_allocated_dimensions(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dimensions_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dimensions_.IsDefault()) {
          _impl_.dimensions_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.cps2004.Furniture.dimensions)
}

inline bool Furniture::has_furniture_type() const {
  return furniture_type_case() != FURNITURE_TYPE_NOT_SET;
}
inline void Furniture::clear_has_furniture_type() {
  _impl_._oneof_case_[0] = FURNITURE_TYPE_NOT_SET;
}
inline Furniture::FurnitureTypeCase Furniture::furniture_type_case() const {
  return Furniture::FurnitureTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Table

// .com.cps2004.Furniture furniture = 1;
inline bool Table::has_furniture() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.furniture_ != nullptr);
  return value;
}
inline void Table::clear_furniture() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.furniture_ != nullptr) _impl_.furniture_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::com::cps2004::Furniture& Table::_internal_furniture() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::cps2004::Furniture* p = _impl_.furniture_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::cps2004::Furniture&>(::com::cps2004::_Furniture_default_instance_);
}
inline const ::com::cps2004::Furniture& Table::furniture() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Table.furniture)
  return _internal_furniture();
}
inline void Table::unsafe_arena_set_allocated_furniture(::com::cps2004::Furniture* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.furniture_);
  }
  _impl_.furniture_ = reinterpret_cast<::com::cps2004::Furniture*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.cps2004.Table.furniture)
}
inline ::com::cps2004::Furniture* Table::release_furniture() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::cps2004::Furniture* released = _impl_.furniture_;
  _impl_.furniture_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::cps2004::Furniture* Table::unsafe_arena_release_furniture() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.cps2004.Table.furniture)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::cps2004::Furniture* temp = _impl_.furniture_;
  _impl_.furniture_ = nullptr;
  return temp;
}
inline ::com::cps2004::Furniture* Table::_internal_mutable_furniture() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.furniture_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::cps2004::Furniture>(GetArena());
    _impl_.furniture_ = reinterpret_cast<::com::cps2004::Furniture*>(p);
  }
  return _impl_.furniture_;
}
inline ::com::cps2004::Furniture* Table::mutable_furniture() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::cps2004::Furniture* _msg = _internal_mutable_furniture();
  // @@protoc_insertion_point(field_mutable:com.cps2004.Table.furniture)
  return _msg;
}
inline void Table::set_allocated_furniture(::com::cps2004::Furniture* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::cps2004::Furniture*>(_impl_.furniture_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::cps2004::Furniture*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.furniture_ = reinterpret_cast<::com::cps2004::Furniture*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.cps2004.Table.furniture)
}

// bool extendable = 2;
inline void Table::clear_extendable() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.extendable_ = false;
}
inline bool Table::extendable() const {
  // @@protoc_insertion_point(field_get:com.cps2004.Table.extendable)
  return _internal_extendable();
}
inline void Table::set_extendable(bool value) {
  _internal_set_extendable(value);
  // @@protoc_insertion_point(field_set:com.cps2004.Table.extendable)
}
inline bool Table::_internal_extendable() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.extendable_;
}
inline void Table::_internal_set_extendable(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.extendable_ = value;
}

// string shape = 3;
inline void Table::clear_shape() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.shape_.ClearToEmpty();
}
inline const std::string& Table::shape() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Table.shape)
  return _internal_shape();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Table::set_shape(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.shape_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:com.cps2004.Table.shape)
}
inline std::string* Table::mutable_shape() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_shape();
  // @@protoc_insertion_point(field_mutable:com.cps2004.Table.shape)
  return _s;
}
inline const std::string& Table::_internal_shape() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.shape_.Get();
}
inline void Table::_internal_set_shape(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.shape_.Set(value, GetArena());
}
inline std::string* Table::_internal_mutable_shape() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.shape_.Mutable( GetArena());
}
inline std::string* Table::release_shape() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.cps2004.Table.shape)
  return _impl_.shape_.Release();
}
inline void Table::set_allocated_shape(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.shape_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.shape_.IsDefault()) {
          _impl_.shape_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.cps2004.Table.shape)
}

// int32 noOfLegs = 4;
inline void Table::clear_nooflegs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nooflegs_ = 0;
}
inline ::int32_t Table::nooflegs() const {
  // @@protoc_insertion_point(field_get:com.cps2004.Table.noOfLegs)
  return _internal_nooflegs();
}
inline void Table::set_nooflegs(::int32_t value) {
  _internal_set_nooflegs(value);
  // @@protoc_insertion_point(field_set:com.cps2004.Table.noOfLegs)
}
inline ::int32_t Table::_internal_nooflegs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nooflegs_;
}
inline void Table::_internal_set_nooflegs(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.nooflegs_ = value;
}

// -------------------------------------------------------------------

// Chair

// .com.cps2004.Furniture furniture = 1;
inline bool Chair::has_furniture() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.furniture_ != nullptr);
  return value;
}
inline void Chair::clear_furniture() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.furniture_ != nullptr) _impl_.furniture_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::com::cps2004::Furniture& Chair::_internal_furniture() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::cps2004::Furniture* p = _impl_.furniture_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::cps2004::Furniture&>(::com::cps2004::_Furniture_default_instance_);
}
inline const ::com::cps2004::Furniture& Chair::furniture() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Chair.furniture)
  return _internal_furniture();
}
inline void Chair::unsafe_arena_set_allocated_furniture(::com::cps2004::Furniture* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.furniture_);
  }
  _impl_.furniture_ = reinterpret_cast<::com::cps2004::Furniture*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.cps2004.Chair.furniture)
}
inline ::com::cps2004::Furniture* Chair::release_furniture() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::cps2004::Furniture* released = _impl_.furniture_;
  _impl_.furniture_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::cps2004::Furniture* Chair::unsafe_arena_release_furniture() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.cps2004.Chair.furniture)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::cps2004::Furniture* temp = _impl_.furniture_;
  _impl_.furniture_ = nullptr;
  return temp;
}
inline ::com::cps2004::Furniture* Chair::_internal_mutable_furniture() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.furniture_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::cps2004::Furniture>(GetArena());
    _impl_.furniture_ = reinterpret_cast<::com::cps2004::Furniture*>(p);
  }
  return _impl_.furniture_;
}
inline ::com::cps2004::Furniture* Chair::mutable_furniture() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::cps2004::Furniture* _msg = _internal_mutable_furniture();
  // @@protoc_insertion_point(field_mutable:com.cps2004.Chair.furniture)
  return _msg;
}
inline void Chair::set_allocated_furniture(::com::cps2004::Furniture* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::cps2004::Furniture*>(_impl_.furniture_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::cps2004::Furniture*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.furniture_ = reinterpret_cast<::com::cps2004::Furniture*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.cps2004.Chair.furniture)
}

// double seatLength = 2;
inline void Chair::clear_seatlength() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.seatlength_ = 0;
}
inline double Chair::seatlength() const {
  // @@protoc_insertion_point(field_get:com.cps2004.Chair.seatLength)
  return _internal_seatlength();
}
inline void Chair::set_seatlength(double value) {
  _internal_set_seatlength(value);
  // @@protoc_insertion_point(field_set:com.cps2004.Chair.seatLength)
}
inline double Chair::_internal_seatlength() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.seatlength_;
}
inline void Chair::_internal_set_seatlength(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.seatlength_ = value;
}

// bool armRests = 3;
inline void Chair::clear_armrests() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.armrests_ = false;
}
inline bool Chair::armrests() const {
  // @@protoc_insertion_point(field_get:com.cps2004.Chair.armRests)
  return _internal_armrests();
}
inline void Chair::set_armrests(bool value) {
  _internal_set_armrests(value);
  // @@protoc_insertion_point(field_set:com.cps2004.Chair.armRests)
}
inline bool Chair::_internal_armrests() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.armrests_;
}
inline void Chair::_internal_set_armrests(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.armrests_ = value;
}

// -------------------------------------------------------------------

// VideoGame

// .com.cps2004.Action action = 1;
inline bool VideoGame::has_action() const {
  return videoGame_type_case() == kAction;
}
inline bool VideoGame::_internal_has_action() const {
  return videoGame_type_case() == kAction;
}
inline void VideoGame::set_has_action() {
  _impl_._oneof_case_[0] = kAction;
}
inline void VideoGame::clear_action() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (videoGame_type_case() == kAction) {
    if (GetArena() == nullptr) {
      delete _impl_.videoGame_type_.action_;
    }
    clear_has_videoGame_type();
  }
}
inline ::com::cps2004::Action* VideoGame::release_action() {
  // @@protoc_insertion_point(field_release:com.cps2004.VideoGame.action)
  if (videoGame_type_case() == kAction) {
    clear_has_videoGame_type();
    auto* temp = _impl_.videoGame_type_.action_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.videoGame_type_.action_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::com::cps2004::Action& VideoGame::_internal_action() const {
  return videoGame_type_case() == kAction ? *_impl_.videoGame_type_.action_ : reinterpret_cast<::com::cps2004::Action&>(::com::cps2004::_Action_default_instance_);
}
inline const ::com::cps2004::Action& VideoGame::action() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.VideoGame.action)
  return _internal_action();
}
inline ::com::cps2004::Action* VideoGame::unsafe_arena_release_action() {
  // @@protoc_insertion_point(field_unsafe_arena_release:com.cps2004.VideoGame.action)
  if (videoGame_type_case() == kAction) {
    clear_has_videoGame_type();
    auto* temp = _impl_.videoGame_type_.action_;
    _impl_.videoGame_type_.action_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void VideoGame::unsafe_arena_set_allocated_action(::com::cps2004::Action* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_videoGame_type();
  if (value) {
    set_has_action();
    _impl_.videoGame_type_.action_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.cps2004.VideoGame.action)
}
inline ::com::cps2004::Action* VideoGame::_internal_mutable_action() {
  if (videoGame_type_case() != kAction) {
    clear_videoGame_type();
    set_has_action();
    _impl_.videoGame_type_.action_ = CreateMaybeMessage<::com::cps2004::Action>(GetArena());
  }
  return _impl_.videoGame_type_.action_;
}
inline ::com::cps2004::Action* VideoGame::mutable_action() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::cps2004::Action* _msg = _internal_mutable_action();
  // @@protoc_insertion_point(field_mutable:com.cps2004.VideoGame.action)
  return _msg;
}

// .com.cps2004.RPG rpg = 2;
inline bool VideoGame::has_rpg() const {
  return videoGame_type_case() == kRpg;
}
inline bool VideoGame::_internal_has_rpg() const {
  return videoGame_type_case() == kRpg;
}
inline void VideoGame::set_has_rpg() {
  _impl_._oneof_case_[0] = kRpg;
}
inline void VideoGame::clear_rpg() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (videoGame_type_case() == kRpg) {
    if (GetArena() == nullptr) {
      delete _impl_.videoGame_type_.rpg_;
    }
    clear_has_videoGame_type();
  }
}
inline ::com::cps2004::RPG* VideoGame::release_rpg() {
  // @@protoc_insertion_point(field_release:com.cps2004.VideoGame.rpg)
  if (videoGame_type_case() == kRpg) {
    clear_has_videoGame_type();
    auto* temp = _impl_.videoGame_type_.rpg_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.videoGame_type_.rpg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::com::cps2004::RPG& VideoGame::_internal_rpg() const {
  return videoGame_type_case() == kRpg ? *_impl_.videoGame_type_.rpg_ : reinterpret_cast<::com::cps2004::RPG&>(::com::cps2004::_RPG_default_instance_);
}
inline const ::com::cps2004::RPG& VideoGame::rpg() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.VideoGame.rpg)
  return _internal_rpg();
}
inline ::com::cps2004::RPG* VideoGame::unsafe_arena_release_rpg() {
  // @@protoc_insertion_point(field_unsafe_arena_release:com.cps2004.VideoGame.rpg)
  if (videoGame_type_case() == kRpg) {
    clear_has_videoGame_type();
    auto* temp = _impl_.videoGame_type_.rpg_;
    _impl_.videoGame_type_.rpg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void VideoGame::unsafe_arena_set_allocated_rpg(::com::cps2004::RPG* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_videoGame_type();
  if (value) {
    set_has_rpg();
    _impl_.videoGame_type_.rpg_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.cps2004.VideoGame.rpg)
}
inline ::com::cps2004::RPG* VideoGame::_internal_mutable_rpg() {
  if (videoGame_type_case() != kRpg) {
    clear_videoGame_type();
    set_has_rpg();
    _impl_.videoGame_type_.rpg_ = CreateMaybeMessage<::com::cps2004::RPG>(GetArena());
  }
  return _impl_.videoGame_type_.rpg_;
}
inline ::com::cps2004::RPG* VideoGame::mutable_rpg() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::cps2004::RPG* _msg = _internal_mutable_rpg();
  // @@protoc_insertion_point(field_mutable:com.cps2004.VideoGame.rpg)
  return _msg;
}

// .com.cps2004.Product product = 3;
inline bool VideoGame::has_product() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.product_ != nullptr);
  return value;
}
inline void VideoGame::clear_product() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.product_ != nullptr) _impl_.product_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::com::cps2004::Product& VideoGame::_internal_product() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::cps2004::Product* p = _impl_.product_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::cps2004::Product&>(::com::cps2004::_Product_default_instance_);
}
inline const ::com::cps2004::Product& VideoGame::product() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.VideoGame.product)
  return _internal_product();
}
inline void VideoGame::unsafe_arena_set_allocated_product(::com::cps2004::Product* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.product_);
  }
  _impl_.product_ = reinterpret_cast<::com::cps2004::Product*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.cps2004.VideoGame.product)
}
inline ::com::cps2004::Product* VideoGame::release_product() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::cps2004::Product* released = _impl_.product_;
  _impl_.product_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::cps2004::Product* VideoGame::unsafe_arena_release_product() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.cps2004.VideoGame.product)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::cps2004::Product* temp = _impl_.product_;
  _impl_.product_ = nullptr;
  return temp;
}
inline ::com::cps2004::Product* VideoGame::_internal_mutable_product() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.product_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::cps2004::Product>(GetArena());
    _impl_.product_ = reinterpret_cast<::com::cps2004::Product*>(p);
  }
  return _impl_.product_;
}
inline ::com::cps2004::Product* VideoGame::mutable_product() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::cps2004::Product* _msg = _internal_mutable_product();
  // @@protoc_insertion_point(field_mutable:com.cps2004.VideoGame.product)
  return _msg;
}
inline void VideoGame::set_allocated_product(::com::cps2004::Product* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::cps2004::Product*>(_impl_.product_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::cps2004::Product*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.product_ = reinterpret_cast<::com::cps2004::Product*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.cps2004.VideoGame.product)
}

// string platform = 4;
inline void VideoGame::clear_platform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.platform_.ClearToEmpty();
}
inline const std::string& VideoGame::platform() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.VideoGame.platform)
  return _internal_platform();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VideoGame::set_platform(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.platform_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:com.cps2004.VideoGame.platform)
}
inline std::string* VideoGame::mutable_platform() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_platform();
  // @@protoc_insertion_point(field_mutable:com.cps2004.VideoGame.platform)
  return _s;
}
inline const std::string& VideoGame::_internal_platform() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.platform_.Get();
}
inline void VideoGame::_internal_set_platform(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.platform_.Set(value, GetArena());
}
inline std::string* VideoGame::_internal_mutable_platform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.platform_.Mutable( GetArena());
}
inline std::string* VideoGame::release_platform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.cps2004.VideoGame.platform)
  return _impl_.platform_.Release();
}
inline void VideoGame::set_allocated_platform(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.platform_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.platform_.IsDefault()) {
          _impl_.platform_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.cps2004.VideoGame.platform)
}

// string developer = 5;
inline void VideoGame::clear_developer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.developer_.ClearToEmpty();
}
inline const std::string& VideoGame::developer() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.VideoGame.developer)
  return _internal_developer();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VideoGame::set_developer(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.developer_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:com.cps2004.VideoGame.developer)
}
inline std::string* VideoGame::mutable_developer() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_developer();
  // @@protoc_insertion_point(field_mutable:com.cps2004.VideoGame.developer)
  return _s;
}
inline const std::string& VideoGame::_internal_developer() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.developer_.Get();
}
inline void VideoGame::_internal_set_developer(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.developer_.Set(value, GetArena());
}
inline std::string* VideoGame::_internal_mutable_developer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.developer_.Mutable( GetArena());
}
inline std::string* VideoGame::release_developer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.cps2004.VideoGame.developer)
  return _impl_.developer_.Release();
}
inline void VideoGame::set_allocated_developer(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.developer_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.developer_.IsDefault()) {
          _impl_.developer_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.cps2004.VideoGame.developer)
}

inline bool VideoGame::has_videoGame_type() const {
  return videoGame_type_case() != VIDEOGAME_TYPE_NOT_SET;
}
inline void VideoGame::clear_has_videoGame_type() {
  _impl_._oneof_case_[0] = VIDEOGAME_TYPE_NOT_SET;
}
inline VideoGame::VideoGameTypeCase VideoGame::videoGame_type_case() const {
  return VideoGame::VideoGameTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Action

// .com.cps2004.VideoGame videoGame = 1;
inline bool Action::has_videogame() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.videogame_ != nullptr);
  return value;
}
inline void Action::clear_videogame() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.videogame_ != nullptr) _impl_.videogame_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::com::cps2004::VideoGame& Action::_internal_videogame() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::cps2004::VideoGame* p = _impl_.videogame_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::cps2004::VideoGame&>(::com::cps2004::_VideoGame_default_instance_);
}
inline const ::com::cps2004::VideoGame& Action::videogame() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Action.videoGame)
  return _internal_videogame();
}
inline void Action::unsafe_arena_set_allocated_videogame(::com::cps2004::VideoGame* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.videogame_);
  }
  _impl_.videogame_ = reinterpret_cast<::com::cps2004::VideoGame*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.cps2004.Action.videoGame)
}
inline ::com::cps2004::VideoGame* Action::release_videogame() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::cps2004::VideoGame* released = _impl_.videogame_;
  _impl_.videogame_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::cps2004::VideoGame* Action::unsafe_arena_release_videogame() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.cps2004.Action.videoGame)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::cps2004::VideoGame* temp = _impl_.videogame_;
  _impl_.videogame_ = nullptr;
  return temp;
}
inline ::com::cps2004::VideoGame* Action::_internal_mutable_videogame() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.videogame_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::cps2004::VideoGame>(GetArena());
    _impl_.videogame_ = reinterpret_cast<::com::cps2004::VideoGame*>(p);
  }
  return _impl_.videogame_;
}
inline ::com::cps2004::VideoGame* Action::mutable_videogame() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::cps2004::VideoGame* _msg = _internal_mutable_videogame();
  // @@protoc_insertion_point(field_mutable:com.cps2004.Action.videoGame)
  return _msg;
}
inline void Action::set_allocated_videogame(::com::cps2004::VideoGame* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::cps2004::VideoGame*>(_impl_.videogame_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::cps2004::VideoGame*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.videogame_ = reinterpret_cast<::com::cps2004::VideoGame*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.cps2004.Action.videoGame)
}

// int32 noOfPlayers = 2;
inline void Action::clear_noofplayers() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.noofplayers_ = 0;
}
inline ::int32_t Action::noofplayers() const {
  // @@protoc_insertion_point(field_get:com.cps2004.Action.noOfPlayers)
  return _internal_noofplayers();
}
inline void Action::set_noofplayers(::int32_t value) {
  _internal_set_noofplayers(value);
  // @@protoc_insertion_point(field_set:com.cps2004.Action.noOfPlayers)
}
inline ::int32_t Action::_internal_noofplayers() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.noofplayers_;
}
inline void Action::_internal_set_noofplayers(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.noofplayers_ = value;
}

// string rating = 3;
inline void Action::clear_rating() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rating_.ClearToEmpty();
}
inline const std::string& Action::rating() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Action.rating)
  return _internal_rating();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Action::set_rating(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.rating_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:com.cps2004.Action.rating)
}
inline std::string* Action::mutable_rating() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_rating();
  // @@protoc_insertion_point(field_mutable:com.cps2004.Action.rating)
  return _s;
}
inline const std::string& Action::_internal_rating() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.rating_.Get();
}
inline void Action::_internal_set_rating(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.rating_.Set(value, GetArena());
}
inline std::string* Action::_internal_mutable_rating() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.rating_.Mutable( GetArena());
}
inline std::string* Action::release_rating() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.cps2004.Action.rating)
  return _impl_.rating_.Release();
}
inline void Action::set_allocated_rating(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rating_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.rating_.IsDefault()) {
          _impl_.rating_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.cps2004.Action.rating)
}

// -------------------------------------------------------------------

// RPG

// .com.cps2004.VideoGame videoGame = 1;
inline bool RPG::has_videogame() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.videogame_ != nullptr);
  return value;
}
inline void RPG::clear_videogame() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.videogame_ != nullptr) _impl_.videogame_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::com::cps2004::VideoGame& RPG::_internal_videogame() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::cps2004::VideoGame* p = _impl_.videogame_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::cps2004::VideoGame&>(::com::cps2004::_VideoGame_default_instance_);
}
inline const ::com::cps2004::VideoGame& RPG::videogame() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.RPG.videoGame)
  return _internal_videogame();
}
inline void RPG::unsafe_arena_set_allocated_videogame(::com::cps2004::VideoGame* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.videogame_);
  }
  _impl_.videogame_ = reinterpret_cast<::com::cps2004::VideoGame*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.cps2004.RPG.videoGame)
}
inline ::com::cps2004::VideoGame* RPG::release_videogame() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::cps2004::VideoGame* released = _impl_.videogame_;
  _impl_.videogame_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::cps2004::VideoGame* RPG::unsafe_arena_release_videogame() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.cps2004.RPG.videoGame)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::cps2004::VideoGame* temp = _impl_.videogame_;
  _impl_.videogame_ = nullptr;
  return temp;
}
inline ::com::cps2004::VideoGame* RPG::_internal_mutable_videogame() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.videogame_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::cps2004::VideoGame>(GetArena());
    _impl_.videogame_ = reinterpret_cast<::com::cps2004::VideoGame*>(p);
  }
  return _impl_.videogame_;
}
inline ::com::cps2004::VideoGame* RPG::mutable_videogame() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::cps2004::VideoGame* _msg = _internal_mutable_videogame();
  // @@protoc_insertion_point(field_mutable:com.cps2004.RPG.videoGame)
  return _msg;
}
inline void RPG::set_allocated_videogame(::com::cps2004::VideoGame* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::cps2004::VideoGame*>(_impl_.videogame_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::cps2004::VideoGame*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.videogame_ = reinterpret_cast<::com::cps2004::VideoGame*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.cps2004.RPG.videoGame)
}

// string story = 2;
inline void RPG::clear_story() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.story_.ClearToEmpty();
}
inline const std::string& RPG::story() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.RPG.story)
  return _internal_story();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RPG::set_story(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.story_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:com.cps2004.RPG.story)
}
inline std::string* RPG::mutable_story() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_story();
  // @@protoc_insertion_point(field_mutable:com.cps2004.RPG.story)
  return _s;
}
inline const std::string& RPG::_internal_story() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.story_.Get();
}
inline void RPG::_internal_set_story(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.story_.Set(value, GetArena());
}
inline std::string* RPG::_internal_mutable_story() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.story_.Mutable( GetArena());
}
inline std::string* RPG::release_story() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.cps2004.RPG.story)
  return _impl_.story_.Release();
}
inline void RPG::set_allocated_story(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.story_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.story_.IsDefault()) {
          _impl_.story_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.cps2004.RPG.story)
}

// bool multiplayer = 3;
inline void RPG::clear_multiplayer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.multiplayer_ = false;
}
inline bool RPG::multiplayer() const {
  // @@protoc_insertion_point(field_get:com.cps2004.RPG.multiplayer)
  return _internal_multiplayer();
}
inline void RPG::set_multiplayer(bool value) {
  _internal_set_multiplayer(value);
  // @@protoc_insertion_point(field_set:com.cps2004.RPG.multiplayer)
}
inline bool RPG::_internal_multiplayer() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.multiplayer_;
}
inline void RPG::_internal_set_multiplayer(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.multiplayer_ = value;
}

// -------------------------------------------------------------------

// StockItem

// .com.cps2004.Product product = 1;
inline bool StockItem::has_product() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.product_ != nullptr);
  return value;
}
inline void StockItem::clear_product() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.product_ != nullptr) _impl_.product_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::com::cps2004::Product& StockItem::_internal_product() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::cps2004::Product* p = _impl_.product_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::cps2004::Product&>(::com::cps2004::_Product_default_instance_);
}
inline const ::com::cps2004::Product& StockItem::product() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.StockItem.product)
  return _internal_product();
}
inline void StockItem::unsafe_arena_set_allocated_product(::com::cps2004::Product* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.product_);
  }
  _impl_.product_ = reinterpret_cast<::com::cps2004::Product*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.cps2004.StockItem.product)
}
inline ::com::cps2004::Product* StockItem::release_product() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::cps2004::Product* released = _impl_.product_;
  _impl_.product_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::cps2004::Product* StockItem::unsafe_arena_release_product() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.cps2004.StockItem.product)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::cps2004::Product* temp = _impl_.product_;
  _impl_.product_ = nullptr;
  return temp;
}
inline ::com::cps2004::Product* StockItem::_internal_mutable_product() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.product_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::cps2004::Product>(GetArena());
    _impl_.product_ = reinterpret_cast<::com::cps2004::Product*>(p);
  }
  return _impl_.product_;
}
inline ::com::cps2004::Product* StockItem::mutable_product() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::cps2004::Product* _msg = _internal_mutable_product();
  // @@protoc_insertion_point(field_mutable:com.cps2004.StockItem.product)
  return _msg;
}
inline void StockItem::set_allocated_product(::com::cps2004::Product* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::cps2004::Product*>(_impl_.product_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::cps2004::Product*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.product_ = reinterpret_cast<::com::cps2004::Product*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.cps2004.StockItem.product)
}

// int32 quantity = 2;
inline void StockItem::clear_quantity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.quantity_ = 0;
}
inline ::int32_t StockItem::quantity() const {
  // @@protoc_insertion_point(field_get:com.cps2004.StockItem.quantity)
  return _internal_quantity();
}
inline void StockItem::set_quantity(::int32_t value) {
  _internal_set_quantity(value);
  // @@protoc_insertion_point(field_set:com.cps2004.StockItem.quantity)
}
inline ::int32_t StockItem::_internal_quantity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.quantity_;
}
inline void StockItem::_internal_set_quantity(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.quantity_ = value;
}

// -------------------------------------------------------------------

// Stock

// repeated .com.cps2004.StockItem currentstock = 1;
inline int Stock::_internal_currentstock_size() const {
  return _internal_currentstock().size();
}
inline int Stock::currentstock_size() const {
  return _internal_currentstock_size();
}
inline void Stock::clear_currentstock() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.currentstock_.Clear();
}
inline ::com::cps2004::StockItem* Stock::mutable_currentstock(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:com.cps2004.Stock.currentstock)
  return _internal_mutable_currentstock()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::com::cps2004::StockItem>* Stock::mutable_currentstock()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:com.cps2004.Stock.currentstock)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_currentstock();
}
inline const ::com::cps2004::StockItem& Stock::currentstock(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Stock.currentstock)
  return _internal_currentstock().Get(index);
}
inline ::com::cps2004::StockItem* Stock::add_currentstock() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::com::cps2004::StockItem* _add = _internal_mutable_currentstock()->Add();
  // @@protoc_insertion_point(field_add:com.cps2004.Stock.currentstock)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::com::cps2004::StockItem>& Stock::currentstock() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:com.cps2004.Stock.currentstock)
  return _internal_currentstock();
}
inline const ::google::protobuf::RepeatedPtrField<::com::cps2004::StockItem>&
Stock::_internal_currentstock() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.currentstock_;
}
inline ::google::protobuf::RepeatedPtrField<::com::cps2004::StockItem>*
Stock::_internal_mutable_currentstock() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.currentstock_;
}

// -------------------------------------------------------------------

// ShipmentItem

// int32 id = 1;
inline void ShipmentItem::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t ShipmentItem::id() const {
  // @@protoc_insertion_point(field_get:com.cps2004.ShipmentItem.id)
  return _internal_id();
}
inline void ShipmentItem::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:com.cps2004.ShipmentItem.id)
}
inline ::int32_t ShipmentItem::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void ShipmentItem::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// int32 quantity = 2;
inline void ShipmentItem::clear_quantity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.quantity_ = 0;
}
inline ::int32_t ShipmentItem::quantity() const {
  // @@protoc_insertion_point(field_get:com.cps2004.ShipmentItem.quantity)
  return _internal_quantity();
}
inline void ShipmentItem::set_quantity(::int32_t value) {
  _internal_set_quantity(value);
  // @@protoc_insertion_point(field_set:com.cps2004.ShipmentItem.quantity)
}
inline ::int32_t ShipmentItem::_internal_quantity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.quantity_;
}
inline void ShipmentItem::_internal_set_quantity(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.quantity_ = value;
}

// .com.cps2004.Product product = 3;
inline bool ShipmentItem::has_product() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.product_ != nullptr);
  return value;
}
inline void ShipmentItem::clear_product() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.product_ != nullptr) _impl_.product_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::com::cps2004::Product& ShipmentItem::_internal_product() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::cps2004::Product* p = _impl_.product_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::cps2004::Product&>(::com::cps2004::_Product_default_instance_);
}
inline const ::com::cps2004::Product& ShipmentItem::product() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.ShipmentItem.product)
  return _internal_product();
}
inline void ShipmentItem::unsafe_arena_set_allocated_product(::com::cps2004::Product* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.product_);
  }
  _impl_.product_ = reinterpret_cast<::com::cps2004::Product*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.cps2004.ShipmentItem.product)
}
inline ::com::cps2004::Product* ShipmentItem::release_product() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::cps2004::Product* released = _impl_.product_;
  _impl_.product_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::cps2004::Product* ShipmentItem::unsafe_arena_release_product() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.cps2004.ShipmentItem.product)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::cps2004::Product* temp = _impl_.product_;
  _impl_.product_ = nullptr;
  return temp;
}
inline ::com::cps2004::Product* ShipmentItem::_internal_mutable_product() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.product_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::cps2004::Product>(GetArena());
    _impl_.product_ = reinterpret_cast<::com::cps2004::Product*>(p);
  }
  return _impl_.product_;
}
inline ::com::cps2004::Product* ShipmentItem::mutable_product() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::cps2004::Product* _msg = _internal_mutable_product();
  // @@protoc_insertion_point(field_mutable:com.cps2004.ShipmentItem.product)
  return _msg;
}
inline void ShipmentItem::set_allocated_product(::com::cps2004::Product* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::cps2004::Product*>(_impl_.product_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::cps2004::Product*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.product_ = reinterpret_cast<::com::cps2004::Product*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.cps2004.ShipmentItem.product)
}

// .com.cps2004.Package package = 4;
inline bool ShipmentItem::has_package() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.package_ != nullptr);
  return value;
}
inline void ShipmentItem::clear_package() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.package_ != nullptr) _impl_.package_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::com::cps2004::Package& ShipmentItem::_internal_package() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::cps2004::Package* p = _impl_.package_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::cps2004::Package&>(::com::cps2004::_Package_default_instance_);
}
inline const ::com::cps2004::Package& ShipmentItem::package() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.ShipmentItem.package)
  return _internal_package();
}
inline void ShipmentItem::unsafe_arena_set_allocated_package(::com::cps2004::Package* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.package_);
  }
  _impl_.package_ = reinterpret_cast<::com::cps2004::Package*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.cps2004.ShipmentItem.package)
}
inline ::com::cps2004::Package* ShipmentItem::release_package() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::com::cps2004::Package* released = _impl_.package_;
  _impl_.package_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::cps2004::Package* ShipmentItem::unsafe_arena_release_package() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.cps2004.ShipmentItem.package)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::com::cps2004::Package* temp = _impl_.package_;
  _impl_.package_ = nullptr;
  return temp;
}
inline ::com::cps2004::Package* ShipmentItem::_internal_mutable_package() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.package_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::cps2004::Package>(GetArena());
    _impl_.package_ = reinterpret_cast<::com::cps2004::Package*>(p);
  }
  return _impl_.package_;
}
inline ::com::cps2004::Package* ShipmentItem::mutable_package() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::cps2004::Package* _msg = _internal_mutable_package();
  // @@protoc_insertion_point(field_mutable:com.cps2004.ShipmentItem.package)
  return _msg;
}
inline void ShipmentItem::set_allocated_package(::com::cps2004::Package* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::cps2004::Package*>(_impl_.package_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::cps2004::Package*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.package_ = reinterpret_cast<::com::cps2004::Package*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.cps2004.ShipmentItem.package)
}

// -------------------------------------------------------------------

// Shipment

// .com.cps2004.Transport transport = 1;
inline bool Shipment::has_transport() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.transport_ != nullptr);
  return value;
}
inline void Shipment::clear_transport() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.transport_ != nullptr) _impl_.transport_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::com::cps2004::Transport& Shipment::_internal_transport() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::cps2004::Transport* p = _impl_.transport_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::cps2004::Transport&>(::com::cps2004::_Transport_default_instance_);
}
inline const ::com::cps2004::Transport& Shipment::transport() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Shipment.transport)
  return _internal_transport();
}
inline void Shipment::unsafe_arena_set_allocated_transport(::com::cps2004::Transport* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.transport_);
  }
  _impl_.transport_ = reinterpret_cast<::com::cps2004::Transport*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.cps2004.Shipment.transport)
}
inline ::com::cps2004::Transport* Shipment::release_transport() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::cps2004::Transport* released = _impl_.transport_;
  _impl_.transport_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::cps2004::Transport* Shipment::unsafe_arena_release_transport() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.cps2004.Shipment.transport)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::cps2004::Transport* temp = _impl_.transport_;
  _impl_.transport_ = nullptr;
  return temp;
}
inline ::com::cps2004::Transport* Shipment::_internal_mutable_transport() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.transport_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::cps2004::Transport>(GetArena());
    _impl_.transport_ = reinterpret_cast<::com::cps2004::Transport*>(p);
  }
  return _impl_.transport_;
}
inline ::com::cps2004::Transport* Shipment::mutable_transport() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::cps2004::Transport* _msg = _internal_mutable_transport();
  // @@protoc_insertion_point(field_mutable:com.cps2004.Shipment.transport)
  return _msg;
}
inline void Shipment::set_allocated_transport(::com::cps2004::Transport* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::cps2004::Transport*>(_impl_.transport_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::cps2004::Transport*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.transport_ = reinterpret_cast<::com::cps2004::Transport*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.cps2004.Shipment.transport)
}

// repeated .com.cps2004.ShipmentItem packagedItems = 2;
inline int Shipment::_internal_packageditems_size() const {
  return _internal_packageditems().size();
}
inline int Shipment::packageditems_size() const {
  return _internal_packageditems_size();
}
inline void Shipment::clear_packageditems() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.packageditems_.Clear();
}
inline ::com::cps2004::ShipmentItem* Shipment::mutable_packageditems(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:com.cps2004.Shipment.packagedItems)
  return _internal_mutable_packageditems()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::com::cps2004::ShipmentItem>* Shipment::mutable_packageditems()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:com.cps2004.Shipment.packagedItems)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_packageditems();
}
inline const ::com::cps2004::ShipmentItem& Shipment::packageditems(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Shipment.packagedItems)
  return _internal_packageditems().Get(index);
}
inline ::com::cps2004::ShipmentItem* Shipment::add_packageditems() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::com::cps2004::ShipmentItem* _add = _internal_mutable_packageditems()->Add();
  // @@protoc_insertion_point(field_add:com.cps2004.Shipment.packagedItems)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::com::cps2004::ShipmentItem>& Shipment::packageditems() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:com.cps2004.Shipment.packagedItems)
  return _internal_packageditems();
}
inline const ::google::protobuf::RepeatedPtrField<::com::cps2004::ShipmentItem>&
Shipment::_internal_packageditems() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.packageditems_;
}
inline ::google::protobuf::RepeatedPtrField<::com::cps2004::ShipmentItem>*
Shipment::_internal_mutable_packageditems() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.packageditems_;
}

// bool dispatched = 3;
inline void Shipment::clear_dispatched() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dispatched_ = false;
}
inline bool Shipment::dispatched() const {
  // @@protoc_insertion_point(field_get:com.cps2004.Shipment.dispatched)
  return _internal_dispatched();
}
inline void Shipment::set_dispatched(bool value) {
  _internal_set_dispatched(value);
  // @@protoc_insertion_point(field_set:com.cps2004.Shipment.dispatched)
}
inline bool Shipment::_internal_dispatched() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dispatched_;
}
inline void Shipment::_internal_set_dispatched(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.dispatched_ = value;
}

// double distance = 4;
inline void Shipment::clear_distance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.distance_ = 0;
}
inline double Shipment::distance() const {
  // @@protoc_insertion_point(field_get:com.cps2004.Shipment.distance)
  return _internal_distance();
}
inline void Shipment::set_distance(double value) {
  _internal_set_distance(value);
  // @@protoc_insertion_point(field_set:com.cps2004.Shipment.distance)
}
inline double Shipment::_internal_distance() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.distance_;
}
inline void Shipment::_internal_set_distance(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.distance_ = value;
}

// string dispatchedDate = 5;
inline void Shipment::clear_dispatcheddate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dispatcheddate_.ClearToEmpty();
}
inline const std::string& Shipment::dispatcheddate() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Shipment.dispatchedDate)
  return _internal_dispatcheddate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Shipment::set_dispatcheddate(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.dispatcheddate_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:com.cps2004.Shipment.dispatchedDate)
}
inline std::string* Shipment::mutable_dispatcheddate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_dispatcheddate();
  // @@protoc_insertion_point(field_mutable:com.cps2004.Shipment.dispatchedDate)
  return _s;
}
inline const std::string& Shipment::_internal_dispatcheddate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dispatcheddate_.Get();
}
inline void Shipment::_internal_set_dispatcheddate(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.dispatcheddate_.Set(value, GetArena());
}
inline std::string* Shipment::_internal_mutable_dispatcheddate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.dispatcheddate_.Mutable( GetArena());
}
inline std::string* Shipment::release_dispatcheddate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.cps2004.Shipment.dispatchedDate)
  return _impl_.dispatcheddate_.Release();
}
inline void Shipment::set_allocated_dispatcheddate(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dispatcheddate_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dispatcheddate_.IsDefault()) {
          _impl_.dispatcheddate_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.cps2004.Shipment.dispatchedDate)
}

// int32 shipmentID = 6;
inline void Shipment::clear_shipmentid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.shipmentid_ = 0;
}
inline ::int32_t Shipment::shipmentid() const {
  // @@protoc_insertion_point(field_get:com.cps2004.Shipment.shipmentID)
  return _internal_shipmentid();
}
inline void Shipment::set_shipmentid(::int32_t value) {
  _internal_set_shipmentid(value);
  // @@protoc_insertion_point(field_set:com.cps2004.Shipment.shipmentID)
}
inline ::int32_t Shipment::_internal_shipmentid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.shipmentid_;
}
inline void Shipment::_internal_set_shipmentid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.shipmentid_ = value;
}

// -------------------------------------------------------------------

// Customer

// string name = 1;
inline void Customer::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Customer::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Customer.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Customer::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:com.cps2004.Customer.name)
}
inline std::string* Customer::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:com.cps2004.Customer.name)
  return _s;
}
inline const std::string& Customer::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void Customer::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Customer::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Customer::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.cps2004.Customer.name)
  return _impl_.name_.Release();
}
inline void Customer::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.cps2004.Customer.name)
}

// string address = 2;
inline void Customer::clear_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.address_.ClearToEmpty();
}
inline const std::string& Customer::address() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Customer.address)
  return _internal_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Customer::set_address(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.address_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:com.cps2004.Customer.address)
}
inline std::string* Customer::mutable_address() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:com.cps2004.Customer.address)
  return _s;
}
inline const std::string& Customer::_internal_address() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.address_.Get();
}
inline void Customer::_internal_set_address(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.address_.Set(value, GetArena());
}
inline std::string* Customer::_internal_mutable_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.address_.Mutable( GetArena());
}
inline std::string* Customer::release_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.cps2004.Customer.address)
  return _impl_.address_.Release();
}
inline void Customer::set_allocated_address(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.address_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.address_.IsDefault()) {
          _impl_.address_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.cps2004.Customer.address)
}

// int32 ID = 3;
inline void Customer::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
}
inline ::int32_t Customer::id() const {
  // @@protoc_insertion_point(field_get:com.cps2004.Customer.ID)
  return _internal_id();
}
inline void Customer::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:com.cps2004.Customer.ID)
}
inline ::int32_t Customer::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void Customer::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// double distanceFromWarehouse = 4;
inline void Customer::clear_distancefromwarehouse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.distancefromwarehouse_ = 0;
}
inline double Customer::distancefromwarehouse() const {
  // @@protoc_insertion_point(field_get:com.cps2004.Customer.distanceFromWarehouse)
  return _internal_distancefromwarehouse();
}
inline void Customer::set_distancefromwarehouse(double value) {
  _internal_set_distancefromwarehouse(value);
  // @@protoc_insertion_point(field_set:com.cps2004.Customer.distanceFromWarehouse)
}
inline double Customer::_internal_distancefromwarehouse() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.distancefromwarehouse_;
}
inline void Customer::_internal_set_distancefromwarehouse(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.distancefromwarehouse_ = value;
}

// repeated .com.cps2004.Shipment shipments = 5;
inline int Customer::_internal_shipments_size() const {
  return _internal_shipments().size();
}
inline int Customer::shipments_size() const {
  return _internal_shipments_size();
}
inline void Customer::clear_shipments() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.shipments_.Clear();
}
inline ::com::cps2004::Shipment* Customer::mutable_shipments(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:com.cps2004.Customer.shipments)
  return _internal_mutable_shipments()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::com::cps2004::Shipment>* Customer::mutable_shipments()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:com.cps2004.Customer.shipments)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_shipments();
}
inline const ::com::cps2004::Shipment& Customer::shipments(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.Customer.shipments)
  return _internal_shipments().Get(index);
}
inline ::com::cps2004::Shipment* Customer::add_shipments() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::com::cps2004::Shipment* _add = _internal_mutable_shipments()->Add();
  // @@protoc_insertion_point(field_add:com.cps2004.Customer.shipments)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::com::cps2004::Shipment>& Customer::shipments() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:com.cps2004.Customer.shipments)
  return _internal_shipments();
}
inline const ::google::protobuf::RepeatedPtrField<::com::cps2004::Shipment>&
Customer::_internal_shipments() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.shipments_;
}
inline ::google::protobuf::RepeatedPtrField<::com::cps2004::Shipment>*
Customer::_internal_mutable_shipments() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.shipments_;
}

// -------------------------------------------------------------------

// State

// repeated .com.cps2004.Transport transports = 1;
inline int State::_internal_transports_size() const {
  return _internal_transports().size();
}
inline int State::transports_size() const {
  return _internal_transports_size();
}
inline void State::clear_transports() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.transports_.Clear();
}
inline ::com::cps2004::Transport* State::mutable_transports(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:com.cps2004.State.transports)
  return _internal_mutable_transports()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::com::cps2004::Transport>* State::mutable_transports()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:com.cps2004.State.transports)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_transports();
}
inline const ::com::cps2004::Transport& State::transports(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.State.transports)
  return _internal_transports().Get(index);
}
inline ::com::cps2004::Transport* State::add_transports() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::com::cps2004::Transport* _add = _internal_mutable_transports()->Add();
  // @@protoc_insertion_point(field_add:com.cps2004.State.transports)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::com::cps2004::Transport>& State::transports() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:com.cps2004.State.transports)
  return _internal_transports();
}
inline const ::google::protobuf::RepeatedPtrField<::com::cps2004::Transport>&
State::_internal_transports() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.transports_;
}
inline ::google::protobuf::RepeatedPtrField<::com::cps2004::Transport>*
State::_internal_mutable_transports() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.transports_;
}

// repeated .com.cps2004.Supplier suppliers = 2;
inline int State::_internal_suppliers_size() const {
  return _internal_suppliers().size();
}
inline int State::suppliers_size() const {
  return _internal_suppliers_size();
}
inline void State::clear_suppliers() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.suppliers_.Clear();
}
inline ::com::cps2004::Supplier* State::mutable_suppliers(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:com.cps2004.State.suppliers)
  return _internal_mutable_suppliers()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::com::cps2004::Supplier>* State::mutable_suppliers()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:com.cps2004.State.suppliers)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_suppliers();
}
inline const ::com::cps2004::Supplier& State::suppliers(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.State.suppliers)
  return _internal_suppliers().Get(index);
}
inline ::com::cps2004::Supplier* State::add_suppliers() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::com::cps2004::Supplier* _add = _internal_mutable_suppliers()->Add();
  // @@protoc_insertion_point(field_add:com.cps2004.State.suppliers)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::com::cps2004::Supplier>& State::suppliers() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:com.cps2004.State.suppliers)
  return _internal_suppliers();
}
inline const ::google::protobuf::RepeatedPtrField<::com::cps2004::Supplier>&
State::_internal_suppliers() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.suppliers_;
}
inline ::google::protobuf::RepeatedPtrField<::com::cps2004::Supplier>*
State::_internal_mutable_suppliers() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.suppliers_;
}

// repeated .com.cps2004.Customer customers = 3;
inline int State::_internal_customers_size() const {
  return _internal_customers().size();
}
inline int State::customers_size() const {
  return _internal_customers_size();
}
inline void State::clear_customers() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.customers_.Clear();
}
inline ::com::cps2004::Customer* State::mutable_customers(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:com.cps2004.State.customers)
  return _internal_mutable_customers()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::com::cps2004::Customer>* State::mutable_customers()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:com.cps2004.State.customers)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_customers();
}
inline const ::com::cps2004::Customer& State::customers(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.State.customers)
  return _internal_customers().Get(index);
}
inline ::com::cps2004::Customer* State::add_customers() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::com::cps2004::Customer* _add = _internal_mutable_customers()->Add();
  // @@protoc_insertion_point(field_add:com.cps2004.State.customers)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::com::cps2004::Customer>& State::customers() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:com.cps2004.State.customers)
  return _internal_customers();
}
inline const ::google::protobuf::RepeatedPtrField<::com::cps2004::Customer>&
State::_internal_customers() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.customers_;
}
inline ::google::protobuf::RepeatedPtrField<::com::cps2004::Customer>*
State::_internal_mutable_customers() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.customers_;
}

// repeated .com.cps2004.Package packages = 4;
inline int State::_internal_packages_size() const {
  return _internal_packages().size();
}
inline int State::packages_size() const {
  return _internal_packages_size();
}
inline void State::clear_packages() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.packages_.Clear();
}
inline ::com::cps2004::Package* State::mutable_packages(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:com.cps2004.State.packages)
  return _internal_mutable_packages()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::com::cps2004::Package>* State::mutable_packages()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:com.cps2004.State.packages)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_packages();
}
inline const ::com::cps2004::Package& State::packages(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.State.packages)
  return _internal_packages().Get(index);
}
inline ::com::cps2004::Package* State::add_packages() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::com::cps2004::Package* _add = _internal_mutable_packages()->Add();
  // @@protoc_insertion_point(field_add:com.cps2004.State.packages)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::com::cps2004::Package>& State::packages() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:com.cps2004.State.packages)
  return _internal_packages();
}
inline const ::google::protobuf::RepeatedPtrField<::com::cps2004::Package>&
State::_internal_packages() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.packages_;
}
inline ::google::protobuf::RepeatedPtrField<::com::cps2004::Package>*
State::_internal_mutable_packages() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.packages_;
}

// .com.cps2004.Stock stock = 5;
inline bool State::has_stock() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stock_ != nullptr);
  return value;
}
inline void State::clear_stock() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.stock_ != nullptr) _impl_.stock_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::com::cps2004::Stock& State::_internal_stock() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::com::cps2004::Stock* p = _impl_.stock_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::cps2004::Stock&>(::com::cps2004::_Stock_default_instance_);
}
inline const ::com::cps2004::Stock& State::stock() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.cps2004.State.stock)
  return _internal_stock();
}
inline void State::unsafe_arena_set_allocated_stock(::com::cps2004::Stock* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.stock_);
  }
  _impl_.stock_ = reinterpret_cast<::com::cps2004::Stock*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.cps2004.State.stock)
}
inline ::com::cps2004::Stock* State::release_stock() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::cps2004::Stock* released = _impl_.stock_;
  _impl_.stock_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::com::cps2004::Stock* State::unsafe_arena_release_stock() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:com.cps2004.State.stock)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::com::cps2004::Stock* temp = _impl_.stock_;
  _impl_.stock_ = nullptr;
  return temp;
}
inline ::com::cps2004::Stock* State::_internal_mutable_stock() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.stock_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::cps2004::Stock>(GetArena());
    _impl_.stock_ = reinterpret_cast<::com::cps2004::Stock*>(p);
  }
  return _impl_.stock_;
}
inline ::com::cps2004::Stock* State::mutable_stock() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::cps2004::Stock* _msg = _internal_mutable_stock();
  // @@protoc_insertion_point(field_mutable:com.cps2004.State.stock)
  return _msg;
}
inline void State::set_allocated_stock(::com::cps2004::Stock* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::com::cps2004::Stock*>(_impl_.stock_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::com::cps2004::Stock*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.stock_ = reinterpret_cast<::com::cps2004::Stock*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.cps2004.State.stock)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace cps2004
}  // namespace com


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_data_5fstructures_2eproto_2epb_2eh
